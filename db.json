{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next_8.8/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/css/noscript.styl","path":"css/noscript.styl","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/config.js","path":"js/config.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/comments.js","path":"js/comments.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/schedule.js","path":"js/schedule.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/ye_16.ico","path":"images/ye_16.ico","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/images/ye_32.ico","path":"images/ye_32.ico","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/fancybox.js","path":"js/third-party/fancybox.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/pace.js","path":"js/third-party/pace.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/chat/tidio.js","path":"js/third-party/chat/tidio.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/chat/gitter.js","path":"js/third-party/chat/gitter.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":1,"renderable":1},{"_id":"themes/next_8.8/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Construct-Your-Blog-with-Hexo-and-Github.md","hash":"2236551288477e52d6fa709f8c5e53e94c4e3e60","modified":1639141449220},{"_id":"source/_posts/An-Introduction-to-Git.md","hash":"13d48f3584911d258682f04fb23966307bf958f4","modified":1639142574282},{"_id":"source/_posts/First-Step-to-RL.md","hash":"f696972d5ede6f34db8b61cad641984119fc7d5c","modified":1639141483338},{"_id":"source/categories/index.md","hash":"408ea9b07f3b1a1339731fe7b364d88bc5644aff","modified":1637754696896},{"_id":"source/tags/index.md","hash":"3207ebf9794561395cf0c54633880ab070040ade","modified":1638946119840},{"_id":"source/_posts/First-Step-to-RL/policy_network.py","hash":"b3e8f06360cad0084a0656edaed4539f1b01e327","modified":1638761670499},{"_id":"source/_posts/First-Step-to-RL/q_learning.py","hash":"3a68ec1153d26f2c18c9d34ee5deb5e495b8dca9","modified":1638761670515},{"_id":"themes/next_8.8/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1638944857842},{"_id":"themes/next_8.8/.gitattributes","hash":"aeeca2f1e987d83232d7870d1435a4e3ed66b648","modified":1638944857843},{"_id":"themes/next_8.8/.eslintrc.json","hash":"611e15c3fcb41dc68fa8532ee595a1262a1b5a8a","modified":1638944857842},{"_id":"themes/next_8.8/.gitignore","hash":"087b7677078303acb2acb47432165950e4d29b43","modified":1638944857853},{"_id":"themes/next_8.8/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1638944857853},{"_id":"themes/next_8.8/LICENSE.md","hash":"8cfb03967dd4cbaf3b825271ffce0039aa3fc22a","modified":1638944857853},{"_id":"themes/next_8.8/README.md","hash":"43fe29330352545446a532e6630866251129882a","modified":1638944857854},{"_id":"themes/next_8.8/_config.yml","hash":"04e881c0903eacaa2894ced4cbadaf8a17995cb5","modified":1639018966738},{"_id":"themes/next_8.8/_vendors.yml","hash":"ba72c575e627697a050614411706cb20206d4b71","modified":1638944857855},{"_id":"themes/next_8.8/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1638944857855},{"_id":"themes/next_8.8/package.json","hash":"e527d094273cf3be4766630bbfe6cc8cf1eeb529","modified":1638944857899},{"_id":"themes/next_8.8/renovate.json","hash":"767b077c7b615e20af3cf865813cd64674a9bea6","modified":1638944857899},{"_id":"themes/next_8.8/.githooks/pre-commit","hash":"b69b9d0b51e27d5d4c87c3242f5067c2cda26e44","modified":1638944857844},{"_id":"themes/next_8.8/.github/CODE_OF_CONDUCT.md","hash":"593ae64e72d43c020a697eac65b1f9c3483ff097","modified":1638944857844},{"_id":"themes/next_8.8/.githooks/install.js","hash":"305c2a269818466eed9e381b866c6cd1ad7f8afd","modified":1638944857843},{"_id":"themes/next_8.8/.github/config.yml","hash":"0956bf71b6f36632b63b14d26580458041a5abd2","modified":1638944857847},{"_id":"themes/next_8.8/.github/CONTRIBUTING.md","hash":"2fdca1040427cabfe27cae6754ec5e027ec7092e","modified":1638944857844},{"_id":"themes/next_8.8/.github/PULL_REQUEST_TEMPLATE.md","hash":"a103e2d875f7434191859e5b42075cfa9a4cbcb3","modified":1638944857846},{"_id":"themes/next_8.8/.github/label-commenter-config.yml","hash":"a1aa85a2fc66ff0c52c65bd97b0fa282e297a73f","modified":1638944857848},{"_id":"themes/next_8.8/.github/labeler.yml","hash":"ff76a903609932a867082b8ccced906e9910533a","modified":1638944857848},{"_id":"themes/next_8.8/.github/release-drafter.yml","hash":"de38f816e3023e0a5c1fd1f3c2b626f78bc35246","modified":1638944857848},{"_id":"themes/next_8.8/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1638944857847},{"_id":"themes/next_8.8/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1638944857856},{"_id":"themes/next_8.8/docs/AUTHORS.md","hash":"579014d47f45b27fd1618b9709f0efe9585c7449","modified":1638944857856},{"_id":"themes/next_8.8/docs/LICENSE.txt","hash":"d1cd5a8e83d3bbdb50f902d2b487813da95ddfd3","modified":1638944857857},{"_id":"themes/next_8.8/languages/README.md","hash":"b1c96465b3bc139bf5ba6200974b66581d8ff85a","modified":1638944857859},{"_id":"themes/next_8.8/languages/de.yml","hash":"83023c4246b93a2f89f342afe29a7b9e1185f74f","modified":1638944857859},{"_id":"themes/next_8.8/languages/en.yml","hash":"66445143decfbb5eb7031eb370698e31d5222a7a","modified":1638944857860},{"_id":"themes/next_8.8/languages/ar.yml","hash":"cc7e3e2855348563d746f15c4752b9c63fcdd91a","modified":1638944857859},{"_id":"themes/next_8.8/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1638944857860},{"_id":"themes/next_8.8/languages/es.yml","hash":"07955d78028cea2a590c63fdc2c01ca3ee05a727","modified":1638944857860},{"_id":"themes/next_8.8/languages/fa.yml","hash":"e09fad889ab3ae87874093e1acd51edc9297d869","modified":1638944857861},{"_id":"themes/next_8.8/languages/fr.yml","hash":"328c255c82e9b561e20a9f51a4d84abc63d1b90a","modified":1638944857861},{"_id":"themes/next_8.8/languages/id.yml","hash":"d7c337ca72efb0bd02ade8b5560c559384ad84dd","modified":1638944857861},{"_id":"themes/next_8.8/languages/it.yml","hash":"c038ff0cadbe405750d980bcacfd3900acf96905","modified":1638944857862},{"_id":"themes/next_8.8/languages/ja.yml","hash":"57a35b21aca04ce8bca64fb5933f35626c462ea3","modified":1638944857862},{"_id":"themes/next_8.8/languages/ko.yml","hash":"d6e2add7488065ec4f7d21cfcf7f0eaa877a84f4","modified":1638944857862},{"_id":"themes/next_8.8/languages/nl.yml","hash":"e47858bd1e0d0622c15366ae6c0513d996f589e3","modified":1638944857863},{"_id":"themes/next_8.8/languages/pt-BR.yml","hash":"305025e932832328b7e2a8a584638a23c462e68f","modified":1638944857863},{"_id":"themes/next_8.8/languages/pt.yml","hash":"ff93459250c33d3c7ba06c30164cc4208edf9b33","modified":1638944857863},{"_id":"themes/next_8.8/languages/ru.yml","hash":"7d13108f4a70ff6a162508a49678e4a477fa7b56","modified":1638944857863},{"_id":"themes/next_8.8/languages/si.yml","hash":"c15ed758dbad890e856f4fc281208d7b78cc1a59","modified":1638944857864},{"_id":"themes/next_8.8/languages/tr.yml","hash":"d3262d2221b0583a52e5d20a3cd1380f5dc49378","modified":1638944857864},{"_id":"themes/next_8.8/languages/uk.yml","hash":"f32871f67c63d26bc4e3e15df9b01f5a41236a50","modified":1638944857864},{"_id":"themes/next_8.8/languages/vi.yml","hash":"e452ea8c48993262a3e8fce9d92072cafabfc734","modified":1638944857865},{"_id":"themes/next_8.8/languages/zh-CN.yml","hash":"f8379d15038e22ef7039d91272cb4f36842dbbe1","modified":1638944857865},{"_id":"themes/next_8.8/languages/zh-HK.yml","hash":"c1ee97ceb56da76ecdc7b69fa975f28c8574441b","modified":1638944857865},{"_id":"themes/next_8.8/languages/zh-TW.yml","hash":"70c45076ad722b777956048fcc430eac37844c11","modified":1638944857865},{"_id":"themes/next_8.8/layout/_layout.njk","hash":"2842f3e9fdde5bbd14cac89629221e68d80c8ea1","modified":1638944857866},{"_id":"themes/next_8.8/layout/archive.njk","hash":"aa491dba8f746e626c273a920effedf7d0b32170","modified":1638944857897},{"_id":"themes/next_8.8/layout/category.njk","hash":"82f541452cae76a94ee15cb8d8a888f44260a0fd","modified":1638944857897},{"_id":"themes/next_8.8/layout/index.njk","hash":"fa52c3049871e879980cb6abccdea3792ca4ce70","modified":1638944857898},{"_id":"themes/next_8.8/layout/page.njk","hash":"fddfdee95f5da86eab8a85d6eb1901996d2153cf","modified":1638944857898},{"_id":"themes/next_8.8/layout/post.njk","hash":"707a50e50b90df5fbeaf8407d12895d04163a290","modified":1638944857898},{"_id":"themes/next_8.8/layout/tag.njk","hash":"b6c017d30d08ddd30d66e9c6f3a71aa65d214eac","modified":1638944857899},{"_id":"themes/next_8.8/test/index.js","hash":"983a505399796b9d9e174ba46d89abbdde38f8ee","modified":1638944857965},{"_id":"themes/next_8.8/.github/ISSUE_TEMPLATE/bug-report.md","hash":"032194e7975564176f2109aa8b7c020fa6d5e6b1","modified":1638944857845},{"_id":"themes/next_8.8/.github/ISSUE_TEMPLATE/config.yml","hash":"daeedc5da2ee74ac31cf71846b766ca6499e9fc6","modified":1638944857845},{"_id":"themes/next_8.8/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4a7885fe2c8b25be02ab57c345cd862aeeeeacaf","modified":1638944857846},{"_id":"themes/next_8.8/.github/ISSUE_TEMPLATE/other.md","hash":"618d07b49f4774cd79613d4001984a19d954a6ad","modified":1638944857846},{"_id":"themes/next_8.8/.github/workflows/label-commenter.yml","hash":"7dec949b13131783e726facb2f4acde0945db1b8","modified":1638944857849},{"_id":"themes/next_8.8/.github/workflows/labeler.yml","hash":"46d0b29dc561fe571d91fd06a7c8ef606b984c72","modified":1638944857849},{"_id":"themes/next_8.8/.github/workflows/linter.yml","hash":"b57d876c90d1645a52bbba8a52d47ad0b0c96140","modified":1638944857849},{"_id":"themes/next_8.8/.github/workflows/lock.yml","hash":"58eca481fd71088a8ae1dbc04645bcfc03460b87","modified":1638944857849},{"_id":"themes/next_8.8/.github/workflows/tester.yml","hash":"645bb69d0b6cc062c47fabb1ccb2297ccbcfa7f5","modified":1638944857852},{"_id":"themes/next_8.8/.github/workflows/release-drafter.yml","hash":"359b74890a47d784e35a5cc3c7885d5cdf302e82","modified":1638944857852},{"_id":"themes/next_8.8/.github/workflows/stale.yml","hash":"32e7dfb55ecf8af66aebfed471be09ef2eb10e18","modified":1638944857852},{"_id":"themes/next_8.8/docs/ru/README.md","hash":"e1d6bf38cf34972ca2ee5331a727787fe14082a3","modified":1638944857857},{"_id":"themes/next_8.8/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7befb4325b107dd668d9eae3d7e86a34910ce3f2","modified":1638944857858},{"_id":"themes/next_8.8/docs/zh-CN/CONTRIBUTING.md","hash":"a09ceb82b45dd8b7da76c227f3d0bb7eebe7d5d1","modified":1638944857858},{"_id":"themes/next_8.8/docs/zh-CN/README.md","hash":"354b0b0a24cbe97cccf2ec8bd97eb7d624fa0dea","modified":1638944857858},{"_id":"themes/next_8.8/layout/_macro/post-collapse.njk","hash":"d9d8e6d7a6a8c80009dd5334cc17fd3e4977a008","modified":1638944857867},{"_id":"themes/next_8.8/layout/_macro/post.njk","hash":"367cafd3acc1c6a045d8a72de0479aabbf4a3559","modified":1638944857867},{"_id":"themes/next_8.8/layout/_macro/sidebar.njk","hash":"eec74e135d01948361020140c3798769e1e7363b","modified":1638944857867},{"_id":"themes/next_8.8/layout/_partials/comments.njk","hash":"d6b7bb7764e3b471ed6b4e5715f6cbe2dd453f59","modified":1638944857868},{"_id":"themes/next_8.8/layout/_partials/footer.njk","hash":"0347cb6077a969136aac26ebdc205a7817010ee7","modified":1639127865723},{"_id":"themes/next_8.8/layout/_partials/languages.njk","hash":"537026fc120adeef9148c98ebf074207e3810538","modified":1638944857871},{"_id":"themes/next_8.8/layout/_partials/pagination.njk","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1638944857873},{"_id":"themes/next_8.8/layout/_partials/widgets.njk","hash":"967594ee64805e27b7ff9d957e23ab3f5c948600","modified":1638944857877},{"_id":"themes/next_8.8/layout/_third-party/index.njk","hash":"33a4a3275474bd3bb2e8d1b0ea01b42dda9ea608","modified":1638944857888},{"_id":"themes/next_8.8/layout/_third-party/fancybox.njk","hash":"53ad3c31762b74e5d29787b37d5e494cc4fded9b","modified":1638944857888},{"_id":"themes/next_8.8/layout/_third-party/pace.njk","hash":"13b2a77b4858a127f458ea092b6f713b052befac","modified":1638944857890},{"_id":"themes/next_8.8/layout/_third-party/quicklink.njk","hash":"73bc15a9c3c5c239ab90efa19a1e721f41f3cb93","modified":1638944857890},{"_id":"themes/next_8.8/layout/_third-party/rating.njk","hash":"d0444179fec512760ab1d4f76928d795b971c884","modified":1638944857891},{"_id":"themes/next_8.8/layout/_scripts/index.njk","hash":"4eb65641b47ea9b23ed2ddfd69b18f21d7d8f214","modified":1638944857877},{"_id":"themes/next_8.8/layout/_scripts/vendors.njk","hash":"0a1470440f11362df2b1cd6b6228e273d9f999d6","modified":1638944857877},{"_id":"themes/next_8.8/source/css/_colors.styl","hash":"a88430865c99f47ce1d8240f8895819b8b7b0c06","modified":1638944857912},{"_id":"themes/next_8.8/source/css/_mixins.styl","hash":"2ca820b221fb7458e6ef4fbcff826e1d1cf4b473","modified":1638944857938},{"_id":"themes/next_8.8/source/css/main.styl","hash":"38b8a12681a3a04bed02aa1659054912ed6def11","modified":1638944857948},{"_id":"themes/next_8.8/source/css/noscript.styl","hash":"7dc97674c232f6ca71e48b95e3f66472cd8e9c05","modified":1638944857948},{"_id":"themes/next_8.8/source/js/bookmark.js","hash":"1457291a7244b7786ec35b949d97183e4fbd181d","modified":1638944857950},{"_id":"themes/next_8.8/source/js/comments-buttons.js","hash":"81ea6cbcdf0357094753d7523919c1eafa38e79f","modified":1638944857951},{"_id":"themes/next_8.8/source/js/config.js","hash":"211a9ab35205ccfa6b7c74394bade84da0d00af7","modified":1638944857951},{"_id":"themes/next_8.8/source/js/comments.js","hash":"0b4daf0ce610760bd52e95d423f61f3e1c72442a","modified":1638944857951},{"_id":"themes/next_8.8/source/js/next-boot.js","hash":"b0bdb542a809932182cfbb8772328115142a0b77","modified":1638944857952},{"_id":"themes/next_8.8/source/js/motion.js","hash":"20b979ebe3671cb415e6e7171485d65cc347086e","modified":1638944857952},{"_id":"themes/next_8.8/source/js/pjax.js","hash":"85293c253e0f43540572c4e4615c712325a732e2","modified":1638944857952},{"_id":"themes/next_8.8/source/js/schedule.js","hash":"6dade4388aa6579576a35758075134f573985d57","modified":1638944857953},{"_id":"themes/next_8.8/source/js/utils.js","hash":"c13fa66aae52f59f88881738c00ebdcaf0209496","modified":1638944857963},{"_id":"themes/next_8.8/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1638944857948},{"_id":"themes/next_8.8/source/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1638944857949},{"_id":"themes/next_8.8/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1638944857949},{"_id":"themes/next_8.8/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1638944857949},{"_id":"themes/next_8.8/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1638944857950},{"_id":"themes/next_8.8/source/images/ye_16.ico","hash":"b8fb01b5361da89831d232a831a1532e9822bd72","modified":1638945436254},{"_id":"themes/next_8.8/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1638944857950},{"_id":"themes/next_8.8/scripts/events/index.js","hash":"8bca7ae3cebb3857866d718a562c5d8820fcfbe5","modified":1638944857900},{"_id":"themes/next_8.8/source/images/ye_32.ico","hash":"375c99cd785d93dd989c36604ffbd10ada71322a","modified":1638945436261},{"_id":"themes/next_8.8/scripts/tags/button.js","hash":"86c71c73a63744efbbbb367612871fede0d69529","modified":1638944857909},{"_id":"themes/next_8.8/scripts/tags/caniuse.js","hash":"8e912c715702addaf0cefe63e580e45b97ae8c3f","modified":1638944857909},{"_id":"themes/next_8.8/scripts/tags/center-quote.js","hash":"b4d12e6fe29089be0f43bafc9eea736602cd16bf","modified":1638944857909},{"_id":"themes/next_8.8/scripts/tags/group-pictures.js","hash":"1c609312a71d47f838226346aad5c2e1c35f15dd","modified":1638944857909},{"_id":"themes/next_8.8/scripts/tags/index.js","hash":"255dd1090e8319b557eeca43571f0e4f8aab013b","modified":1638944857910},{"_id":"themes/next_8.8/scripts/tags/link-grid.js","hash":"3f358bb78c5c6fdf45de287f3ead553e3a6a93c2","modified":1638944857910},{"_id":"themes/next_8.8/scripts/tags/mermaid.js","hash":"b3844e168b51a99d495ca05562ffac47677f5728","modified":1638944857911},{"_id":"themes/next_8.8/scripts/tags/pdf.js","hash":"317ba4611020cc840854386dde098dbbe452777e","modified":1638944857911},{"_id":"themes/next_8.8/scripts/tags/note.js","hash":"a12fd53e421400836a3722ae69130969558d6ac0","modified":1638944857911},{"_id":"themes/next_8.8/scripts/tags/tabs.js","hash":"e0ed5fe1bc9d2957952a1aacdf3252d6ef3f9743","modified":1638944857912},{"_id":"themes/next_8.8/scripts/tags/video.js","hash":"f6ad3f52779f0636251238d3cbdc5b6f91cc5aba","modified":1638944857912},{"_id":"themes/next_8.8/scripts/tags/label.js","hash":"c18b0e619a779ed40be7f014db92af18f45fbd5c","modified":1638944857910},{"_id":"themes/next_8.8/scripts/filters/locals.js","hash":"8499b9c8c6cdae8aa7e4f5ec5b4b76037969db76","modified":1638944857905},{"_id":"themes/next_8.8/scripts/filters/default-injects.js","hash":"0c9a1fe9906672724dbf274154a37bac1915ca2c","modified":1638944857905},{"_id":"themes/next_8.8/scripts/filters/minify.js","hash":"9789307212d729c8cb65e3541348938a1965ff6f","modified":1638944857906},{"_id":"themes/next_8.8/scripts/filters/number.js","hash":"63735cb9d02921e25b2606490340a70db89abbec","modified":1638945314670},{"_id":"themes/next_8.8/scripts/filters/post.js","hash":"5a132b7f9280a40b3d5fb40928c8cbbe071fe6f6","modified":1638944857906},{"_id":"themes/next_8.8/scripts/helpers/font.js","hash":"0a6fa582a0890ecaf5f03f758a730936e48aeca1","modified":1638944857907},{"_id":"themes/next_8.8/scripts/helpers/engine.js","hash":"18cc82558e7a9f3b6086c41ce9de0c46e807a66c","modified":1638944857906},{"_id":"themes/next_8.8/scripts/helpers/next-config.js","hash":"e73f43f1bcb46965e317285d6831e129a40ea59b","modified":1638944857907},{"_id":"themes/next_8.8/scripts/helpers/next-vendors.js","hash":"52acbc74c1ead8a77cd3bbcba4e033053683f7d0","modified":1638944857908},{"_id":"themes/next_8.8/scripts/helpers/next-url.js","hash":"98fc68cf3fcd6253bbb94068ab1d86578a4ef9ea","modified":1638944857908},{"_id":"themes/next_8.8/test/helpers/font.js","hash":"6f5076bd3f2724e47b46ca69028393a9b6275cd1","modified":1638944857964},{"_id":"themes/next_8.8/test/tags/button.js","hash":"a50ca44eaec3d91c2958e3157d624cd3e68828c7","modified":1638944857965},{"_id":"themes/next_8.8/test/helpers/next-url.js","hash":"08e84781f1cd54e5634b86877ad9cefae4a78e95","modified":1638944857964},{"_id":"themes/next_8.8/test/helpers/index.js","hash":"2fb58dca3df2fe53116ee2b1232fa26ebe7b2ce5","modified":1638944857964},{"_id":"themes/next_8.8/test/tags/caniuse.js","hash":"2852be850d9103c25114253a45e6c62e32517de4","modified":1638944857965},{"_id":"themes/next_8.8/test/tags/center-quote.js","hash":"2ac4b5a358681691a17e736de06fce0b640a7023","modified":1638944857966},{"_id":"themes/next_8.8/test/tags/group-pictures.js","hash":"8f66d3c6f03fb11d85aa2ab05c9b3c9aa2b4e994","modified":1638944857966},{"_id":"themes/next_8.8/test/tags/index.js","hash":"5cad001936a694bf32d59751cc2b68a66199f976","modified":1638944857966},{"_id":"themes/next_8.8/test/tags/label.js","hash":"6cad7d84c42511459a89cda3971e8ea5cdee0125","modified":1638944857967},{"_id":"themes/next_8.8/test/tags/link-grid.js","hash":"41730266306c02362258384cd73659223928361f","modified":1638944857967},{"_id":"themes/next_8.8/test/tags/mermaid.js","hash":"f718a3d0e303d842e2ca5a3b162539a49e45a520","modified":1638944857967},{"_id":"themes/next_8.8/test/tags/note.js","hash":"161a81ce749e239d2403681372d48ecc1b51d7b9","modified":1638944857968},{"_id":"themes/next_8.8/test/tags/pdf.js","hash":"2d114596a8a180b2f3cd2a9c6528a328961f12d4","modified":1638944857968},{"_id":"themes/next_8.8/test/tags/tabs.js","hash":"b19d2592347eae5d6a7a97ca7e8cec03e8f25b51","modified":1638944857968},{"_id":"themes/next_8.8/test/tags/video.js","hash":"88db9a3a26cd35525c43c0339fcd1c5965ec9518","modified":1638944857969},{"_id":"themes/next_8.8/test/validate/index.js","hash":"560862194991c5963da5a411629d8e6c71d20ee2","modified":1638944857969},{"_id":"themes/next_8.8/layout/_partials/header/menu.njk","hash":"67372599fe025ebe442b73151e5bb56415758356","modified":1638944857870},{"_id":"themes/next_8.8/layout/_partials/header/brand.njk","hash":"8e08c19e1bd92f3179907b0ff3743d6e2371d7ae","modified":1638944857869},{"_id":"themes/next_8.8/layout/_partials/header/menu-item.njk","hash":"f066390762faf6684a523e2eb943420023aac2b1","modified":1638944857870},{"_id":"themes/next_8.8/layout/_partials/header/index.njk","hash":"1b2ae17f3c394ce310fe2d9ed5f4d07d8cc74ae7","modified":1638944857870},{"_id":"themes/next_8.8/layout/_partials/head/head.njk","hash":"abcc550cb14374fb7452d6edee63967ad9583d1c","modified":1638944857869},{"_id":"themes/next_8.8/layout/_partials/head/head-unique.njk","hash":"bd87e3a877ebab4508fc2b48b41c96b45c4dd970","modified":1638944857869},{"_id":"themes/next_8.8/layout/_partials/header/sub-menu.njk","hash":"940cad08a67e6c361214045096bd3cdffdf44fcf","modified":1638944857870},{"_id":"themes/next_8.8/layout/_partials/page/breadcrumb.njk","hash":"9c136edd2248e2d50c1f6110b75e2b75c299bbd7","modified":1638944857871},{"_id":"themes/next_8.8/layout/_partials/page/categories.njk","hash":"b352346dd2cb42f7eeaec5e39d9a2a353b029775","modified":1638944857872},{"_id":"themes/next_8.8/layout/_partials/page/schedule.njk","hash":"130e776575d634201d4f8ef3d78dc12624f19fde","modified":1638944857872},{"_id":"themes/next_8.8/layout/_partials/page/page-header.njk","hash":"92553feb26f30f7fc9147bc4ef122908a9da06be","modified":1638944857872},{"_id":"themes/next_8.8/layout/_partials/page/tags.njk","hash":"752df7d12360a077c51a25609916a3ecc1763bb3","modified":1638944857872},{"_id":"themes/next_8.8/layout/_partials/post/post-followme.njk","hash":"ebf83083856f8bd81ad47ffb985d44e338b4e6bb","modified":1638944857873},{"_id":"themes/next_8.8/layout/_partials/post/post-copyright.njk","hash":"0ebc0142abebbeef4278e32abb543c7d7fa75d88","modified":1638944857873},{"_id":"themes/next_8.8/layout/_partials/post/post-footer.njk","hash":"e3502059bcc443ce932946a9891fcbe8b2bb362d","modified":1638944857874},{"_id":"themes/next_8.8/layout/_partials/post/post-related.njk","hash":"80d3dac42740d2aef677e25165e31c05eb048887","modified":1638944857875},{"_id":"themes/next_8.8/layout/_partials/post/post-reward.njk","hash":"58b3f657a47bae406e5fcf19cd5e42680785ac71","modified":1638944857875},{"_id":"themes/next_8.8/layout/_partials/post/post-meta.njk","hash":"9a9c4fb7e7c4fe4b7d474bdfdb4ed2b0a5423df2","modified":1638944857874},{"_id":"themes/next_8.8/layout/_partials/search/index.njk","hash":"9766852e72c1809d8c1eea71ac6116b4cc0886d2","modified":1638944857876},{"_id":"themes/next_8.8/layout/_partials/search/algolia-search.njk","hash":"93fbb449fbd599cb4315d7eb0daeb239811b233f","modified":1638944857875},{"_id":"themes/next_8.8/layout/_partials/sidebar/site-overview.njk","hash":"c5c38b4fb137cc799a6ec31f391d1efc12234c8c","modified":1638944857876},{"_id":"themes/next_8.8/layout/_partials/search/localsearch.njk","hash":"f73d25a8ccfdd5d4ca2953dc434ff8ce36034c57","modified":1638944857876},{"_id":"themes/next_8.8/layout/_third-party/analytics/baidu-analytics.njk","hash":"3e80332f88b101141be69f2a07f54ed8c053eabb","modified":1638944857880},{"_id":"themes/next_8.8/layout/_third-party/analytics/google-analytics.njk","hash":"52ad137450f7b3d6a330e16b3ed1c6174290f0eb","modified":1638944857881},{"_id":"themes/next_8.8/layout/_third-party/analytics/cloudflare.njk","hash":"c7cea42f6db2137c11ca1d83e43fcb7ad7ccfb89","modified":1638944857881},{"_id":"themes/next_8.8/layout/_third-party/analytics/growingio.njk","hash":"9ff9ec05c2037beea229a6bb698f9e3546973220","modified":1638944857882},{"_id":"themes/next_8.8/layout/_third-party/analytics/index.njk","hash":"465fcffd4216f8ca0ea2613fe9cf7308f71b9da5","modified":1638944857882},{"_id":"themes/next_8.8/layout/_third-party/chat/chatra.njk","hash":"09d2c9487d75894d45a823e3237ae9f90fd6ee01","modified":1638944857882},{"_id":"themes/next_8.8/layout/_third-party/chat/tidio.njk","hash":"3fbc72427c1211e5dcfd269af1a74852a7ba5c1a","modified":1638944857883},{"_id":"themes/next_8.8/layout/_third-party/chat/gitter.njk","hash":"375a86f0b19e130cfa7707007e3a53d9ae7c9b64","modified":1638944857883},{"_id":"themes/next_8.8/layout/_third-party/comments/changyan.njk","hash":"5f7967bd946060f4102263a552ddfbae9975e7ea","modified":1638944857884},{"_id":"themes/next_8.8/layout/_third-party/comments/disqus.njk","hash":"b0828dd1b1fd66ecd612d9e886a08e7579e9a4f7","modified":1638944857884},{"_id":"themes/next_8.8/layout/_third-party/comments/isso.njk","hash":"38badcc7624a13961381c2465478056b9602aee5","modified":1638944857885},{"_id":"themes/next_8.8/layout/_third-party/comments/disqusjs.njk","hash":"c5086b4c35f730f82c99c4a8317f2f153ebde869","modified":1638944857884},{"_id":"themes/next_8.8/layout/_third-party/comments/gitalk.njk","hash":"6fd4df5c21cfe530dbb0c012bc0b202f2c362b9c","modified":1638944857884},{"_id":"themes/next_8.8/layout/_third-party/comments/utterances.njk","hash":"a7921be7328e1509d33b435175f5333a9aada66f","modified":1638944857888},{"_id":"themes/next_8.8/layout/_third-party/comments/livere.njk","hash":"b8e0d5de584cece5e05b03db5b86145aa1e422b4","modified":1638944857885},{"_id":"themes/next_8.8/layout/_third-party/math/index.njk","hash":"1856c4b035c5b8e64300a11af0461b519dfc4cf4","modified":1638944857889},{"_id":"themes/next_8.8/layout/_third-party/math/katex.njk","hash":"a84db8bc8804335f95609a221ac1746433dcdc89","modified":1638944857889},{"_id":"themes/next_8.8/layout/_third-party/math/mathjax.njk","hash":"a62aa1ed4e35b8d0451d83f341bf0a97538bc9a4","modified":1638944857890},{"_id":"themes/next_8.8/layout/_third-party/search/algolia-search.njk","hash":"67f67a77f27103177b9940446f43610229536d82","modified":1638944857891},{"_id":"themes/next_8.8/layout/_third-party/search/localsearch.njk","hash":"210c32b654adae3d8076c4417d370b42af258cea","modified":1638944857891},{"_id":"themes/next_8.8/layout/_third-party/tags/mermaid.njk","hash":"dd8f963acd5a3685be46fd5319c06df0308d99b2","modified":1638944857896},{"_id":"themes/next_8.8/layout/_third-party/tags/pdf.njk","hash":"0386c708975cc5faea4f782611c5d2c6b8ac2850","modified":1638944857897},{"_id":"themes/next_8.8/layout/_third-party/statistics/busuanzi-counter.njk","hash":"d97790e4b442a1e3ded7d7b4f84b8ee6cdb6e8ea","modified":1638944857892},{"_id":"themes/next_8.8/layout/_third-party/statistics/firestore.njk","hash":"af5336e8bbdc4638435971da115bb7443d374ade","modified":1638944857892},{"_id":"themes/next_8.8/layout/_third-party/statistics/index.njk","hash":"866ffa15a3250678eb8a90aa6f609fa965db90fd","modified":1638944857895},{"_id":"themes/next_8.8/layout/_third-party/statistics/lean-analytics.njk","hash":"8703d1855bb8d251c9b7c2940b7e3be525e53000","modified":1638944857895},{"_id":"themes/next_8.8/source/css/_variables/Mist.styl","hash":"ee5024be8e39605f0c6d71db038e15e0693d0f41","modified":1638944857946},{"_id":"themes/next_8.8/source/css/_variables/Gemini.styl","hash":"c4537fa2de33d98baff2c87a73801770414e0b69","modified":1638944857946},{"_id":"themes/next_8.8/source/css/_variables/Muse.styl","hash":"d3a8f6e71c86926d0c2a247a31d7446d829736d5","modified":1638944857946},{"_id":"themes/next_8.8/source/css/_variables/base.styl","hash":"0876b50a58f114bc0b7982b85c5e5011730253b8","modified":1638944857947},{"_id":"themes/next_8.8/source/css/_variables/Pisces.styl","hash":"58014a2d087c4126058a99b5b1cb7d8a2eb6224d","modified":1638944857947},{"_id":"themes/next_8.8/source/js/schemes/muse.js","hash":"e1b4bf9aa47d14c790a0920d7dbb3e9812d4358b","modified":1638944857953},{"_id":"themes/next_8.8/source/js/third-party/fancybox.js","hash":"8a847a7bbdbc0086dd1de12b82107a854b43f5e5","modified":1638944857958},{"_id":"themes/next_8.8/source/js/third-party/pace.js","hash":"0ebee77b2307bf4b260afb06c060171ef42b7141","modified":1638944857959},{"_id":"themes/next_8.8/source/js/third-party/quicklink.js","hash":"539c5bb51244f7f4aa98884f3229d128c1cefc40","modified":1638944857960},{"_id":"themes/next_8.8/source/js/third-party/rating.js","hash":"a1f44247c18ac00ee3e0026560398429e4c77dd7","modified":1638944857960},{"_id":"themes/next_8.8/scripts/events/lib/config.js","hash":"a912944cae0d864458d365867b8a9c89f348e68a","modified":1638944857900},{"_id":"themes/next_8.8/scripts/events/lib/highlight.js","hash":"00cec6980cafd417def885f496371856cd524a25","modified":1638944857901},{"_id":"themes/next_8.8/scripts/events/lib/injects.js","hash":"1f1ea7b579a49f17574c31d78d663c54896133eb","modified":1638944857901},{"_id":"themes/next_8.8/scripts/events/lib/utils.js","hash":"8508e96a5f883a5a57d8c1b8b5ea438fa29aafd3","modified":1638944857901},{"_id":"themes/next_8.8/scripts/events/lib/vendors.js","hash":"2f7057a8d3fce08aa7e2a17d7b7a1f03ac3d8ed6","modified":1638944857902},{"_id":"themes/next_8.8/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1638944857903},{"_id":"themes/next_8.8/scripts/filters/comment/changyan.js","hash":"cfff8331fdaa2ede4ab08c58cfc6d98c7d2374d9","modified":1638944857902},{"_id":"themes/next_8.8/scripts/filters/comment/default-config.js","hash":"1cb58aa6b88f7461c3c3f9605273686adcc30979","modified":1638944857903},{"_id":"themes/next_8.8/scripts/filters/comment/disqus.js","hash":"3283bdd6e5ac7d10376df8ddd5faaec5dc1bd667","modified":1638944857903},{"_id":"themes/next_8.8/scripts/filters/comment/disqusjs.js","hash":"70eb507ef7f1a4fc3ca71a3814cc57afe7f3f60c","modified":1638944857903},{"_id":"themes/next_8.8/scripts/filters/comment/isso.js","hash":"c22cbccd7d514947e084eeac6a3af1aa41ec857a","modified":1638944857904},{"_id":"themes/next_8.8/scripts/filters/comment/gitalk.js","hash":"96e58efba0dc76af409cc7d2db225f0fe4526ea8","modified":1638944857904},{"_id":"themes/next_8.8/scripts/filters/comment/utterances.js","hash":"a50718c081685fd35ff8ea9ca13682c284399ed8","modified":1638944857905},{"_id":"themes/next_8.8/scripts/filters/comment/livere.js","hash":"bb8ebb541c40362c0cbbd8e83d3b777302bb6c40","modified":1638944857904},{"_id":"themes/next_8.8/source/css/_common/components/back-to-top.styl","hash":"2bbf9046ef2a8f99ef3668bbb8be4e52e9d97bb7","modified":1638944857913},{"_id":"themes/next_8.8/source/css/_common/components/index.styl","hash":"991c1f80995cec418dc00d3d6b13e2d911ac9894","modified":1638944857913},{"_id":"themes/next_8.8/source/css/_common/components/reading-progress.styl","hash":"f3defd56be33dba4866a695396d96c767ce63182","modified":1638944857920},{"_id":"themes/next_8.8/source/css/_common/scaffolding/base.styl","hash":"1239f1b432a6932b2bb9ebcfbaabf724b8f4e59a","modified":1638944857931},{"_id":"themes/next_8.8/source/css/_common/scaffolding/buttons.styl","hash":"f768ecb2fe3e9384777c1c115cd7409e9155edd7","modified":1638944857932},{"_id":"themes/next_8.8/source/css/_common/scaffolding/comments.styl","hash":"cf8446f4378dcab27b55ede1635c608ae6b8a5c8","modified":1638944857932},{"_id":"themes/next_8.8/source/css/_common/scaffolding/index.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1638944857933},{"_id":"themes/next_8.8/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1638944857933},{"_id":"themes/next_8.8/source/css/_common/scaffolding/pagination.styl","hash":"34416a5792d0235caa8c0c7e59725f2df0fa614c","modified":1638944857934},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tables.styl","hash":"b9388016f8d9274703e77e306a1feaad1b7b9d6c","modified":1638944857934},{"_id":"themes/next_8.8/source/css/_common/scaffolding/toggles.styl","hash":"90f7d3baab061e860172b536c9edc38c7fd2ef5c","modified":1638944857938},{"_id":"themes/next_8.8/source/css/_common/outline/index.styl","hash":"7782dfae7a0f8cd61b936fa8ac980440a7bbd3bb","modified":1638944857927},{"_id":"themes/next_8.8/source/css/_common/outline/mobile.styl","hash":"2db4462e9cb87b8aef3f50f850fed407de16da3e","modified":1638944857927},{"_id":"themes/next_8.8/source/css/_schemes/Gemini/index.styl","hash":"f51b6a4f06359ed56b2d10caa6f15362d3b3751d","modified":1638944857939},{"_id":"themes/next_8.8/source/css/_schemes/Mist/_header.styl","hash":"b1054313ca9419e76fea0451417c881616f50a38","modified":1638944857939},{"_id":"themes/next_8.8/source/css/_schemes/Mist/_layout.styl","hash":"00366a6bd1a66f99f845c5ebfc9e8cf56651b815","modified":1638944857939},{"_id":"themes/next_8.8/source/css/_schemes/Mist/_menu.styl","hash":"f337981f8f20944ed366694aea88146c7b0a13ab","modified":1638944857940},{"_id":"themes/next_8.8/source/css/_schemes/Mist/_posts-expand.styl","hash":"c9a9e07b721bb2376e24753ae0a9452431439114","modified":1638944857941},{"_id":"themes/next_8.8/source/css/_schemes/Mist/index.styl","hash":"89bf3f6b82cb0fafbbd483431df8f450857c5a0b","modified":1638944857941},{"_id":"themes/next_8.8/source/css/_schemes/Muse/_menu.styl","hash":"28030c61288cc0e1321b18373a5c79029fd76a53","modified":1638944857942},{"_id":"themes/next_8.8/source/css/_schemes/Muse/_header.styl","hash":"fd89988442f380cba907752fe3f608e3498f8c93","modified":1638944857941},{"_id":"themes/next_8.8/source/css/_schemes/Muse/_layout.styl","hash":"018b6a761e197086174c9f06b4d5ea21cc230951","modified":1638944857941},{"_id":"themes/next_8.8/source/css/_schemes/Muse/_sidebar.styl","hash":"134272cb8096156c9e32fbbe085394633c7509cd","modified":1638944857942},{"_id":"themes/next_8.8/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1638944857943},{"_id":"themes/next_8.8/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1638944857943},{"_id":"themes/next_8.8/source/css/_schemes/Pisces/_header.styl","hash":"9b2cba0c9aa5a64957294f7548c199db1f63f0f4","modified":1638944857943},{"_id":"themes/next_8.8/source/css/_schemes/Pisces/_layout.styl","hash":"9f60d501808f67d151af437221d0dfacc27c180c","modified":1638944857944},{"_id":"themes/next_8.8/source/css/_schemes/Pisces/_menu.styl","hash":"1d29eca70fa686d895f8e98a283e4a159e40905a","modified":1638944857944},{"_id":"themes/next_8.8/source/css/_schemes/Pisces/_sidebar.styl","hash":"42bf453def88da82c842dca84e8f47087091f08e","modified":1638944857944},{"_id":"themes/next_8.8/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5c3dd08c520a16ee49f85fa12b4935e725ef261","modified":1638944857945},{"_id":"themes/next_8.8/source/css/_schemes/Pisces/index.styl","hash":"7905f428b46d100ac5928875cb1e2b99fa86fc0b","modified":1638944857945},{"_id":"themes/next_8.8/source/js/third-party/analytics/baidu-analytics.js","hash":"f9579a02599de063ccff336177ba964a2931a6e9","modified":1638944857954},{"_id":"themes/next_8.8/source/js/third-party/analytics/google-analytics.js","hash":"d77d4934d959e7125128754b568f1d041c3fbfff","modified":1638944857954},{"_id":"themes/next_8.8/source/js/third-party/analytics/growingio.js","hash":"f755e8537ccbbb0bd84c26923f320d4e206e7428","modified":1638944857954},{"_id":"themes/next_8.8/source/js/third-party/comments/changyan.js","hash":"b1dd519dc3b1153c9d2ba2d35f68ca8f73f33bae","modified":1638944857956},{"_id":"themes/next_8.8/source/js/third-party/comments/disqus.js","hash":"5460de247c038d6cfbe774d7f8747f0a958d9017","modified":1638944857956},{"_id":"themes/next_8.8/source/js/third-party/comments/disqusjs.js","hash":"1c282d6c2151346d1f0aa95055d17abe77054ec9","modified":1638944857957},{"_id":"themes/next_8.8/source/js/third-party/comments/gitalk.js","hash":"1e8509356fb027d948d118ab220d9631f4d482fa","modified":1638944857957},{"_id":"themes/next_8.8/source/js/third-party/comments/isso.js","hash":"b9b9fd2f0e098a123b34a4932da912a9485ffe6c","modified":1638944857957},{"_id":"themes/next_8.8/source/js/third-party/comments/livere.js","hash":"68892d74ef5fc308c6e7e6b4f190826d79f3055d","modified":1638944857957},{"_id":"themes/next_8.8/source/js/third-party/comments/utterances.js","hash":"ec44d7f1c8b51b0aa3cccba099a78f3575ac828c","modified":1638944857958},{"_id":"themes/next_8.8/source/js/third-party/chat/chatra.js","hash":"72e0766752b78a723fb30e92d533a8b353104e2d","modified":1638944857955},{"_id":"themes/next_8.8/source/js/third-party/chat/tidio.js","hash":"77c231bcd64f1c09bd9989909e9fee703b65f47f","modified":1638944857955},{"_id":"themes/next_8.8/source/js/third-party/chat/gitter.js","hash":"14b024c920a8b359777d79dd8e1a849387f8f3ad","modified":1638944857955},{"_id":"themes/next_8.8/source/js/third-party/math/katex.js","hash":"5c63ec71458b4fe0cd98fd4a04e11c3746764f11","modified":1638944857959},{"_id":"themes/next_8.8/source/js/third-party/math/mathjax.js","hash":"d93556184b2c0aa1dbc4a6fb892d2f77b80d7d9f","modified":1638944857959},{"_id":"themes/next_8.8/source/js/third-party/search/algolia-search.js","hash":"ea94731438d8c518d946601f8f46a65b92381fac","modified":1638944857960},{"_id":"themes/next_8.8/source/js/third-party/search/local-search.js","hash":"dc2b0e89aa32afc7f7a7e2d7a277dadb7f96e06d","modified":1638944857961},{"_id":"themes/next_8.8/source/js/third-party/statistics/lean-analytics.js","hash":"6abdc209f4503d4efd676e18bc30ddea813b6ff9","modified":1638944857961},{"_id":"themes/next_8.8/source/js/third-party/statistics/firestore.js","hash":"d0829fe41d2fe86b8499e2a896556c1275ea0066","modified":1638944857961},{"_id":"themes/next_8.8/source/js/third-party/tags/mermaid.js","hash":"2618135cbcee6bf228f6734767de1995e5eaaac6","modified":1638944857962},{"_id":"themes/next_8.8/source/js/third-party/tags/pdf.js","hash":"e109c2d6828f527f0289d5fa3bb02fce63ee6d93","modified":1638944857962},{"_id":"themes/next_8.8/source/css/_common/components/pages/breadcrumb.styl","hash":"fde10ce94e9ae21a03b60d41d532835b54abdcb1","modified":1638944857914},{"_id":"themes/next_8.8/source/css/_common/components/pages/index.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1638944857915},{"_id":"themes/next_8.8/source/css/_common/components/pages/schedule.styl","hash":"091b8c763e43447d087c122a86538f290f83136a","modified":1638944857915},{"_id":"themes/next_8.8/source/css/_common/components/pages/tag-cloud.styl","hash":"56d719bcdcba3d725141c55bbd4b168f3942f912","modified":1638944857916},{"_id":"themes/next_8.8/source/css/_common/components/pages/categories.styl","hash":"80595d274f593b321c0b644a06f3165fe07b16f5","modified":1638944857914},{"_id":"themes/next_8.8/source/css/_common/components/post/index.styl","hash":"df2fbd0ada00f37439b0de965c6f1c29d3c97429","modified":1638944857916},{"_id":"themes/next_8.8/source/css/_common/components/post/post-collapse.styl","hash":"eebe3013a9a976011570dce2d04dfeae4c31d790","modified":1638944857917},{"_id":"themes/next_8.8/source/css/_common/components/post/post-body.styl","hash":"7a34d020877273dcf11c25fa481409300efb8659","modified":1638944857917},{"_id":"themes/next_8.8/source/css/_common/components/post/post-footer.styl","hash":"e53a5eb1d1771e284044bdb0bc0ed2de27923669","modified":1638944857918},{"_id":"themes/next_8.8/source/css/_common/components/post/post-followme.styl","hash":"791bc9befb0d4d06e3e517eccfe0bc3551a02a60","modified":1638944857917},{"_id":"themes/next_8.8/source/css/_common/components/post/post-gallery.styl","hash":"c34936a17c3d8af6c0988ac6746d7509dc0b50eb","modified":1638944857918},{"_id":"themes/next_8.8/source/css/_common/components/post/post-header.styl","hash":"4d29b6ae7ed3dc44b10df851a4128b6441efa8be","modified":1638944857918},{"_id":"themes/next_8.8/source/css/_common/components/post/post-nav.styl","hash":"69dff7cf231d01f85671758455726dd666664a73","modified":1638944857918},{"_id":"themes/next_8.8/source/css/_common/components/post/post-widgets.styl","hash":"0a779f955a0e25df0852e0731517dadb234aa181","modified":1638944857919},{"_id":"themes/next_8.8/source/css/_common/components/post/post-reward.styl","hash":"9043d9bc2db35ca000c79258ef89fdb161dc43fb","modified":1638944857919},{"_id":"themes/next_8.8/source/css/_common/components/third-party/disqusjs.styl","hash":"c1e9edbfd1c3696b35d5452ae2e6d766f3fe91aa","modified":1638944857920},{"_id":"themes/next_8.8/source/css/_common/components/third-party/gitalk.styl","hash":"fb165c1a0d990c5cf98b87773e0dc50410229b96","modified":1638944857920},{"_id":"themes/next_8.8/source/css/_common/components/third-party/index.styl","hash":"25ea9a0af888355b3a046db1100b5cb0e2d6ef6e","modified":1638944857921},{"_id":"themes/next_8.8/source/css/_common/components/third-party/math.styl","hash":"1e5776ad4c5c8bcf7596ac74dcabc30704b3f5a0","modified":1638944857921},{"_id":"themes/next_8.8/source/css/_common/components/third-party/search.styl","hash":"49c26184580fde8a732899a4de5aae8662e289b8","modified":1638944857922},{"_id":"themes/next_8.8/source/css/_common/components/third-party/related-posts.styl","hash":"0527153aa821bdbdb84c7b47f60e3cefd95a742f","modified":1638944857921},{"_id":"themes/next_8.8/source/css/_common/components/third-party/utterances.styl","hash":"d28856f365a9373c4ae6fe1e5673d63df2dfd65f","modified":1638944857922},{"_id":"themes/next_8.8/source/css/_common/scaffolding/highlight/index.styl","hash":"5f706f3382652835379cf9b9fec24ccd4513ab65","modified":1638944857933},{"_id":"themes/next_8.8/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"a4003e1408844568cb5102a5a111046cb19b2d31","modified":1638944857933},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"8d9218980e185210ce034e9769ab639b9630fd88","modified":1638944857935},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"6b3680e0dbea8e14c1cec24ef63b7fae5e37f7ef","modified":1638944857935},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/index.styl","hash":"e22fde6f1657d311d46f64d868c4491d535c8caa","modified":1638944857935},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/link-grid.styl","hash":"7075dd32dd70da1e161e4bd14b46f1e8be62fa3c","modified":1638944857936},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/label.styl","hash":"531daf2612c6217950677a2d03924459ce57c291","modified":1638944857936},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/mermaid.styl","hash":"c7754dc6c866928b538f0863a05b96ec44b5e986","modified":1638944857936},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/pdf.styl","hash":"77122986509a6b4968bae2729417b7016137534c","modified":1638944857937},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/note.styl","hash":"2e9dc3b3546e19e9de18050ad04b1741841116bc","modified":1638944857937},{"_id":"themes/next_8.8/source/css/_common/scaffolding/tags/tabs.styl","hash":"40a38f2129617ffd4e8d5cd78e982fdfc9941acf","modified":1638944857937},{"_id":"themes/next_8.8/source/css/_common/outline/footer/index.styl","hash":"02b6d1a53f7a02c6b0929b11f3ab904b5b873a0e","modified":1638944857923},{"_id":"themes/next_8.8/source/css/_common/outline/header/bookmark.styl","hash":"c8648c8ea3105556be0068d9fb2735261d0d94bc","modified":1638944857923},{"_id":"themes/next_8.8/source/css/_common/outline/header/github-banner.styl","hash":"05af22f3edc2383a3d97ec4c05e9ac43b014bead","modified":1638944857924},{"_id":"themes/next_8.8/source/css/_common/outline/header/menu.styl","hash":"2db695204d39e4c7daa7b91585a0ea4b06b49f11","modified":1638944857926},{"_id":"themes/next_8.8/source/css/_common/outline/header/index.styl","hash":"67fc7a1eb59c8451eec34e572cbb2fd1424757bc","modified":1638944857924},{"_id":"themes/next_8.8/source/css/_common/outline/header/site-meta.styl","hash":"86b0925e968f35bbc76b473a861e8f9797f7580e","modified":1638944857926},{"_id":"themes/next_8.8/source/css/_common/outline/header/site-nav.styl","hash":"d9bc2b520636b9df7f946295cd430593df4118ff","modified":1638944857926},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/index.styl","hash":"9964a96f9a647cfb16b97679eced79d07e084e6d","modified":1638944857928},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2c2bfbc34b6f19d262ae7c041474985e12f4f4ad","modified":1638944857928},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"d8a028f532d562e6a86bb3b9c7b992e4b6dbbb51","modified":1638944857929},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"1c324d56ae83e96db2c4c6d63edd7ee51c936fc1","modified":1638944857929},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"63d8f5f169c2b1c969928fc79244c5fe89ee484e","modified":1638944857929},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"57ed6770535ecb2e6485a0c87d4de6d6476368b9","modified":1638944857929},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"db4f3263b2b6551dd56bfdf33cceaf81661a3611","modified":1638944857930},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"081345490271840855d1238b969dbf2e0a2bba8f","modified":1638944857930},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"6681ffe283f8a7e3c86310ef4f6ca1e499c1a19f","modified":1638944857930},{"_id":"themes/next_8.8/source/css/_common/outline/sidebar/site-state.styl","hash":"2de038def2cb91da143b14696366c14a66e0e569","modified":1638944857931},{"_id":"public/sitemap.xml","hash":"71d4d99d9c244e17fc546126884df21650e02fbb","modified":1639143228368},{"_id":"public/tags/index.html","hash":"ebbb153a5f20accd156c2dc059e938e86facf81a","modified":1639143228368},{"_id":"public/categories/index.html","hash":"c26caf17e3b9d11909c66af7dd2d3d035f1754aa","modified":1639143228368},{"_id":"public/2021/12/10/An-Introduction-to-Git/index.html","hash":"f8482c541d7f60b174a1af49c314b8594af959da","modified":1639143228368},{"_id":"public/archives/index.html","hash":"ef456f9d223b628f79e3147db1b3e5e860c953b2","modified":1639143228368},{"_id":"public/archives/2021/index.html","hash":"b1d700c2253ae3f9b4ee587a520c3cfc7e6cc79a","modified":1639143228368},{"_id":"public/archives/2021/11/index.html","hash":"39a88e3400f4d9ff9b37a3234d531793f6a7960f","modified":1639143228368},{"_id":"public/archives/2021/12/index.html","hash":"1c55dd03131a5194c4e6633742d17a545ffd788b","modified":1639143228368},{"_id":"public/categories/Little-Things/index.html","hash":"0ebe7dea28e14d7bb839ad3d4a181c56140f531d","modified":1639143228368},{"_id":"public/categories/Little-Things/Hexo/index.html","hash":"8085035ef8275e82b8e698c1a937a69dda6570bb","modified":1639143228368},{"_id":"public/categories/Little-Things/Git/index.html","hash":"b4101c944cb26a7bc9b66920eb4206a6acfdefff","modified":1639143228368},{"_id":"public/tags/Hexo/index.html","hash":"1eeebb5ae02468eb62ef48b8abdee2a6189e1ea3","modified":1639143228368},{"_id":"public/tags/Git/index.html","hash":"5236eac7c61142a920dfae1e5859314467c90b03","modified":1639143228368},{"_id":"public/categories/Reinforcement-Learning/index.html","hash":"bd11af978a07ac88adcde70b225ca549b4394f95","modified":1639143228368},{"_id":"public/tags/Reinforcement-Learning/index.html","hash":"b90d1a4c00919ac072e6c43e6b24b5f3df4480ed","modified":1639143228368},{"_id":"public/2021/12/03/First-Step-to-RL/index.html","hash":"4a2db6ddc05bbbfea3974f4a451da6ce355cbfb0","modified":1639143228368},{"_id":"public/2021/11/24/Construct-Your-Blog-with-Hexo-and-Github/index.html","hash":"b56695ff34f1da35a7078427b5481c616c8064fc","modified":1639143228368},{"_id":"public/index.html","hash":"9ab5b1e19ef2555fed46c178e1a64ea85f956660","modified":1639143228368},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1639143228368},{"_id":"public/images/avatar.gif","hash":"2dbc3e2f2d624b2ca1afe6edc2ca17307f1950c8","modified":1639143228368},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1639143228368},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1639143228368},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1639143228368},{"_id":"public/images/ye_32.ico","hash":"375c99cd785d93dd989c36604ffbd10ada71322a","modified":1639143228368},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1639143228368},{"_id":"public/images/ye_16.ico","hash":"b8fb01b5361da89831d232a831a1532e9822bd72","modified":1639143228368},{"_id":"public/2021/12/03/First-Step-to-RL/q_learning.py","hash":"3a68ec1153d26f2c18c9d34ee5deb5e495b8dca9","modified":1639143228368},{"_id":"public/2021/12/03/First-Step-to-RL/policy_network.py","hash":"b3e8f06360cad0084a0656edaed4539f1b01e327","modified":1639143228368},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1639143228368},{"_id":"public/js/config.js","hash":"4c4ebbe3b3f3841a26f9d5af6d0ba8bc6da01c54","modified":1639143228368},{"_id":"public/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1639143228368},{"_id":"public/js/bookmark.js","hash":"0f563ffbf05fad30e854e413ab17ff7164ab5a53","modified":1639143228368},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1639143228368},{"_id":"public/js/next-boot.js","hash":"48497e2156a10155dc42311633a110c9685692c9","modified":1639143228368},{"_id":"public/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1639143228368},{"_id":"public/js/pjax.js","hash":"919f5281c4a04d11cfd94573ecf57b3dbabd3cc8","modified":1639143228368},{"_id":"public/js/schedule.js","hash":"2b43e2d576a308289880befc27580dbb2aa34439","modified":1639143228368},{"_id":"public/js/utils.js","hash":"e447160d342b1f93df5214b6a733441039ced439","modified":1639143228368},{"_id":"public/css/main.css","hash":"8d254a18fc5bd174a56763f70c08bda10a0e7183","modified":1639143228368},{"_id":"public/js/schemes/muse.js","hash":"9a836d2bcc3defe4bd1ee51f5f4eb7006ebdd41b","modified":1639143228368},{"_id":"public/js/third-party/fancybox.js","hash":"c098d14e65dd170537134358d4b8359ad0539c2c","modified":1639143228368},{"_id":"public/js/third-party/pace.js","hash":"0ef04218b93561ba4d0ff420d556c3d90a756d32","modified":1639143228368},{"_id":"public/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1639143228368},{"_id":"public/js/third-party/rating.js","hash":"4e92c2d107ba47b47826829f9668030d5ea9bfb8","modified":1639143228368},{"_id":"public/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1639143228368},{"_id":"public/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1639143228368},{"_id":"public/js/third-party/comments/disqus.js","hash":"e1cc671b0d524864fd445e3ab4ade9ee6d07e565","modified":1639143228368},{"_id":"public/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1639143228368},{"_id":"public/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1639143228368},{"_id":"public/js/third-party/comments/changyan.js","hash":"8c8ebec444c727b704ea41ad88b0b96ed2e4b8d4","modified":1639143228368},{"_id":"public/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1639143228368},{"_id":"public/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1639143228368},{"_id":"public/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1639143228368},{"_id":"public/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1639143228368},{"_id":"public/js/third-party/chat/chatra.js","hash":"c32180522788c10e51df1803aa6842ef0432ddc9","modified":1639143228368},{"_id":"public/js/third-party/chat/tidio.js","hash":"b0079f6a4601e06ca6fe46e83a2f5af553e9bc3c","modified":1639143228368},{"_id":"public/js/third-party/chat/gitter.js","hash":"cc38c94125f90dadde11b5ebac7d8bf99a1a08a2","modified":1639143228368},{"_id":"public/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1639143228368},{"_id":"public/js/third-party/statistics/lean-analytics.js","hash":"5a928990856b8e456f0663cf3b6b406733672e39","modified":1639143228368},{"_id":"public/js/third-party/math/mathjax.js","hash":"5c749b9c1c3bb738122d0516211ecff6496d4907","modified":1639143228368},{"_id":"public/js/third-party/statistics/firestore.js","hash":"0960f16107ed61452fb0dffc6ed22dc143de34ef","modified":1639143228368},{"_id":"public/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1639143228368},{"_id":"public/js/third-party/search/local-search.js","hash":"45c485f82258d246f37deb66884bd2643323ef3a","modified":1639143228368},{"_id":"public/js/third-party/search/algolia-search.js","hash":"ac401e3736d56a3c9cb85ab885744cce0b813c55","modified":1639143228368},{"_id":"public/js/third-party/tags/mermaid.js","hash":"3dc4628efa6debd6490fc0ebddff2424a7b319d8","modified":1639143228368}],"Category":[{"name":"Little Things","_id":"ckx0fk1vi0004xoul35qkdqc0"},{"name":"Hexo","parent":"ckx0fk1vi0004xoul35qkdqc0","_id":"ckx0fk1vn0009xoul6nplajat"},{"name":"Git","parent":"ckx0fk1vi0004xoul35qkdqc0","_id":"ckx0fk1vo000bxoul7gdt49wf"},{"name":"Reinforcement Learning","_id":"ckx0fk1vq000hxoulb6zfgsag"}],"Data":[],"Page":[{"title":"tags","date":"2021-12-08T06:48:06.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-12-08 14:48:06\ntype: \"tags\"\n---\n","updated":"2021-12-08T06:48:39.840Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckx0fk1v90000xoulb4wf6ay4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2021-11-24T11:46:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-11-24 19:46:36\ntype: \"categories\"\n---\n","updated":"2021-11-24T11:51:36.896Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckx0fk1ve0002xoul45z56f3d","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Construct Your Blog with Hexo and Github","date":"2021-11-24T08:20:43.000Z","_content":"\n\n# 主要参考了三篇博客\n\nhttps://segmentfault.com/a/1190000017986794\n\nhttps://godweiyang.com/2018/04/13/hexo-blog/\n\nhttps://blog.guaoxiaohei.com/posts/Hexo-Level/\n\n# 实现的时候也遇到了一些问题\n\n<!-- more -->\n\n## 本地显示没问题，hexo d之后 在GitHub无法显示主题样式\n\n更改主目录下面的_config.yml文件\n\n\n\nurl: github远程仓库的地址, 如 https://xyegithub.github.io/myBlog/\n\nroot: url的最后一段，如/myBlog/\n\n更改保存之后，hexo clean; hexo g; hexo d\n\n##  git在推送的时候很容易出现网络错误\n\n参考博客\n\nhttps://juejin.cn/post/6844904193170341896\n\n刷新dns管理员cmd下运行 ipconfig /flushdns\n\n但是这个方法不是很管用\n\n### 更好的方法\n\n可以不用代理，将hexo _config.yml里的git地址由`https://github.com/xxx`修改为ssh `git@github.com:xxx/xxx`也可以\n\n## 将github page 设置为谷歌可搜索\n\n参考博客\n\nhttps://mizeri.github.io/2021/04/18/hexo-sitemap-google/\n","source":"_posts/Construct-Your-Blog-with-Hexo-and-Github.md","raw":"---\ntitle: Construct Your Blog with Hexo and Github\ndate: 2021-11-24 16:20:43\ntags: \n- Hexo\ncategories:\n- Little Things\n- Hexo\n---\n\n\n# 主要参考了三篇博客\n\nhttps://segmentfault.com/a/1190000017986794\n\nhttps://godweiyang.com/2018/04/13/hexo-blog/\n\nhttps://blog.guaoxiaohei.com/posts/Hexo-Level/\n\n# 实现的时候也遇到了一些问题\n\n<!-- more -->\n\n## 本地显示没问题，hexo d之后 在GitHub无法显示主题样式\n\n更改主目录下面的_config.yml文件\n\n\n\nurl: github远程仓库的地址, 如 https://xyegithub.github.io/myBlog/\n\nroot: url的最后一段，如/myBlog/\n\n更改保存之后，hexo clean; hexo g; hexo d\n\n##  git在推送的时候很容易出现网络错误\n\n参考博客\n\nhttps://juejin.cn/post/6844904193170341896\n\n刷新dns管理员cmd下运行 ipconfig /flushdns\n\n但是这个方法不是很管用\n\n### 更好的方法\n\n可以不用代理，将hexo _config.yml里的git地址由`https://github.com/xxx`修改为ssh `git@github.com:xxx/xxx`也可以\n\n## 将github page 设置为谷歌可搜索\n\n参考博客\n\nhttps://mizeri.github.io/2021/04/18/hexo-sitemap-google/\n","slug":"Construct-Your-Blog-with-Hexo-and-Github","published":1,"updated":"2021-12-10T13:04:09.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx0fk1vb0001xoulcrslha8f","content":"<h1 id=\"主要参考了三篇博客\"><span class=\"post-title-index\">1. </span><a href=\"#主要参考了三篇博客\" class=\"headerlink\" title=\"主要参考了三篇博客\"></a>主要参考了三篇博客</h1><p><a href=\"https://segmentfault.com/a/1190000017986794\">https://segmentfault.com/a/1190000017986794</a></p>\n<p><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>\n<p><a href=\"https://blog.guaoxiaohei.com/posts/Hexo-Level/\">https://blog.guaoxiaohei.com/posts/Hexo-Level/</a></p>\n<h1 id=\"实现的时候也遇到了一些问题\"><span class=\"post-title-index\">2. </span><a href=\"#实现的时候也遇到了一些问题\" class=\"headerlink\" title=\"实现的时候也遇到了一些问题\"></a>实现的时候也遇到了一些问题</h1><span id=\"more\"></span>\n\n<h2 id=\"本地显示没问题，hexo-d之后-在GitHub无法显示主题样式\"><span class=\"post-title-index\">2.1. </span><a href=\"#本地显示没问题，hexo-d之后-在GitHub无法显示主题样式\" class=\"headerlink\" title=\"本地显示没问题，hexo d之后 在GitHub无法显示主题样式\"></a>本地显示没问题，hexo d之后 在GitHub无法显示主题样式</h2><p>更改主目录下面的_config.yml文件</p>\n<p>url: github远程仓库的地址, 如 <a href=\"https://xyegithub.github.io/myBlog/\">https://xyegithub.github.io/myBlog/</a></p>\n<p>root: url的最后一段，如/myBlog/</p>\n<p>更改保存之后，hexo clean; hexo g; hexo d</p>\n<h2 id=\"git在推送的时候很容易出现网络错误\"><span class=\"post-title-index\">2.2. </span><a href=\"#git在推送的时候很容易出现网络错误\" class=\"headerlink\" title=\"git在推送的时候很容易出现网络错误\"></a>git在推送的时候很容易出现网络错误</h2><p>参考博客</p>\n<p><a href=\"https://juejin.cn/post/6844904193170341896\">https://juejin.cn/post/6844904193170341896</a></p>\n<p>刷新dns管理员cmd下运行 ipconfig /flushdns</p>\n<p>但是这个方法不是很管用</p>\n<h3 id=\"更好的方法\"><span class=\"post-title-index\">2.2.1. </span><a href=\"#更好的方法\" class=\"headerlink\" title=\"更好的方法\"></a>更好的方法</h3><p>可以不用代理，将hexo _config.yml里的git地址由<code>https://github.com/xxx</code>修改为ssh <code>git@github.com:xxx/xxx</code>也可以</p>\n<h2 id=\"将github-page-设置为谷歌可搜索\"><span class=\"post-title-index\">2.3. </span><a href=\"#将github-page-设置为谷歌可搜索\" class=\"headerlink\" title=\"将github page 设置为谷歌可搜索\"></a>将github page 设置为谷歌可搜索</h2><p>参考博客</p>\n<p><a href=\"https://mizeri.github.io/2021/04/18/hexo-sitemap-google/\">https://mizeri.github.io/2021/04/18/hexo-sitemap-google/</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"主要参考了三篇博客\"><a href=\"#主要参考了三篇博客\" class=\"headerlink\" title=\"主要参考了三篇博客\"></a>主要参考了三篇博客</h1><p><a href=\"https://segmentfault.com/a/1190000017986794\">https://segmentfault.com/a/1190000017986794</a></p>\n<p><a href=\"https://godweiyang.com/2018/04/13/hexo-blog/\">https://godweiyang.com/2018/04/13/hexo-blog/</a></p>\n<p><a href=\"https://blog.guaoxiaohei.com/posts/Hexo-Level/\">https://blog.guaoxiaohei.com/posts/Hexo-Level/</a></p>\n<h1 id=\"实现的时候也遇到了一些问题\"><a href=\"#实现的时候也遇到了一些问题\" class=\"headerlink\" title=\"实现的时候也遇到了一些问题\"></a>实现的时候也遇到了一些问题</h1>","more":"<h2 id=\"本地显示没问题，hexo-d之后-在GitHub无法显示主题样式\"><a href=\"#本地显示没问题，hexo-d之后-在GitHub无法显示主题样式\" class=\"headerlink\" title=\"本地显示没问题，hexo d之后 在GitHub无法显示主题样式\"></a>本地显示没问题，hexo d之后 在GitHub无法显示主题样式</h2><p>更改主目录下面的_config.yml文件</p>\n<p>url: github远程仓库的地址, 如 <a href=\"https://xyegithub.github.io/myBlog/\">https://xyegithub.github.io/myBlog/</a></p>\n<p>root: url的最后一段，如/myBlog/</p>\n<p>更改保存之后，hexo clean; hexo g; hexo d</p>\n<h2 id=\"git在推送的时候很容易出现网络错误\"><a href=\"#git在推送的时候很容易出现网络错误\" class=\"headerlink\" title=\"git在推送的时候很容易出现网络错误\"></a>git在推送的时候很容易出现网络错误</h2><p>参考博客</p>\n<p><a href=\"https://juejin.cn/post/6844904193170341896\">https://juejin.cn/post/6844904193170341896</a></p>\n<p>刷新dns管理员cmd下运行 ipconfig /flushdns</p>\n<p>但是这个方法不是很管用</p>\n<h3 id=\"更好的方法\"><a href=\"#更好的方法\" class=\"headerlink\" title=\"更好的方法\"></a>更好的方法</h3><p>可以不用代理，将hexo _config.yml里的git地址由<code>https://github.com/xxx</code>修改为ssh <code>git@github.com:xxx/xxx</code>也可以</p>\n<h2 id=\"将github-page-设置为谷歌可搜索\"><a href=\"#将github-page-设置为谷歌可搜索\" class=\"headerlink\" title=\"将github page 设置为谷歌可搜索\"></a>将github page 设置为谷歌可搜索</h2><p>参考博客</p>\n<p><a href=\"https://mizeri.github.io/2021/04/18/hexo-sitemap-google/\">https://mizeri.github.io/2021/04/18/hexo-sitemap-google/</a></p>"},{"title":"An Introduction to Git","date":"2021-12-10T09:20:59.000Z","_content":"\nasffda\n","source":"_posts/An-Introduction-to-Git.md","raw":"---\ntitle: An Introduction to Git\ndate: 2021-12-10 17:20:59\ncategories:\n- Little Things\n- Git\ntags:\n- Git\n---\n\nasffda\n","slug":"An-Introduction-to-Git","published":1,"updated":"2021-12-10T13:22:54.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx0fk1vf0003xoulhdpr8bxn","content":"<p>asffda</p>\n","site":{"data":{}},"excerpt":"","more":"<p>asffda</p>\n"},{"title":"First Step to Reinforcement Learing","date":"2021-12-03T08:48:41.000Z","_content":"\n\n\n强化学习的入门介绍\n\n什么是强化学习\n\n深度强化学习算法：策略网络(Policy Network)和估值网络(Value Network)\n\n<!-- more -->\n\n# 什么是强化学习，关于强化学习的几点疑问\n\n<font color=green size=3>强化学习三要素：环境状态，行动，奖励</font>\n\n<font color=green size=3>目标：尽量多的获得奖励</font>\n\n<font color=green size=3>本质：连续决策</font>\n\n基本的强化学习模型包括：\n\n* 环境状态的集合S\n* 动作的集合A\n* 状态之间的转换规则（是环境的一部分）\n* 规定转换后“即时奖励”的规则（是环境的一部分）\n* 描述主体（智能体）能够观察到什么的规则（是环境的一部分）\n* 能够做出决策/动作的主体（智能体）\n\n## 区别于深度学习，强化学习的本质特点是什么？\n\n**两个定义**\n\n1，强化学习是机器学习的一个重要分支，主要用来解决连续决策问题。\n\n2，强化学习又称 再励学习，评价学习或增强学习，是机器学习的范式和方法论之一，用于描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。\n\n强化学习的本质是<font color=red> 描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。</font>它本质是这样一种场景，在这种场景中它为了达到某种目的，做出连续的决策。这样符合这种场景，那就是强化学习。\n\n强化学习和深度学习这两个名词的维度是不一样的。深度学习描述的是算法本身的特点，深度够不够，是不是连接主义的模型。深度学习可以用来做无监督，也可以用来做半监督，也可以用来做弱监督，甚至可以用来作为强化学习算法的一部分。深度学习这个名词，不管应用场景只管模型本身是不是满足深度学习的特点。\n\n而强化学习描述的是应用场景的特点，只要能提供智能体决策的算法，管它是什么模型，什么结构，那就是强化学习的算法。从这个角度上讲，我现在认为强化学习和监督学习，无监督学习，弱监督学习，是并列的，是对应用场景的描述。和深度学习不是同一维度的。\n\n<font color=red>强化学习的本质在于目标给定的形式，不像无监督学习那样完全没有学习目标，也不像监督学习那样有非常明确的目标（label），强化学习的目标一般是变化的，不明确的，甚至可能不存在绝对正确的目标。，强化学习的问题都可以抽象成，环境状态，行动和奖励。应该说只要能抽象为这三个要素，目标是获得最大奖励的模型，就是强化学习的模型。</font>\n\n强化学习的最大的特点是“试错”，是尝试各种可能，而强化结果好的可能。（策略网络的特点，估值网络的特点是修正和预测获益）\n\n由于强化学习是一种决策学习，这个问题的特点就是离散型。但是离散并不就是强化学习（连续的决策才是，目标的模糊和不确定性是决策问题的特点）。深度学习本质是函数的拟合，所以连续可微是它的特点。并不能说连续可微的问题就是深度学习，离散的问题就是强化学习。 \n\n## 深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\n\n这个问题要了解下一节，具体的强化学习方法。\n\n## 强化学习与弱监督学习？\n\n弱监督是属于有监督学习，只是它学习的目标不是被给予的标签，而是比被给予标签更强的标签（强弱是指标签做含有的信息量），也就是说弱监督是根据少量信息的标签，推测出更多的信息。\n\n强化学习的本质是连续决策。连续决策的特点是目标的模糊和不确定性。\n\n所以，虽然弱监督和强化学习都没有给出最终准确的目标，但是他们任然很不同的\n\n## 深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\n\n深度学习大部分我们用作有监督的学习算法。其实说深度学习是死的，不如说有监督学习是死的。\n\n有监督学习其实是完全的复刻标签里面含有的知识，它的本质就是一个函数拟合的问题，它无法摆脱对绝对的标签的依赖，无法超越标签。\n\n而强化学习，正由于它的目标是模糊和不确定的。使得算法在设计上必须具有随机性和探索性，它能够探索出人类从来没有到过的领域。就像在围棋上，下出人类完全无法理解的棋，人从来没有想过的一些下法。这就是强化学习算法探索出来的知识。所以我觉得它是活着的，拥有智能的算法。\n\n<font color=green>从感性的层面，强化学习算法很接近人脑的行为：感知环境，探索环境，强化有益行为</font>\n\n## 关于深度学习，强化学习，连续可导性和离散不可导性的讨论\n\n1. 从函数的角度，深度学习和强化学习都需要学习一个函数映射。深度学习是从输入到target的映射。强化学习是学从环境状态到Action的映射。这两个映射可以看成性质一样的，因为深度学习可以作为强化学习的智能体。所以从函数的角度，他们没有连续和离散的区别。（PS. 深度学习模型和强化学习的智能体都是连续可导的函数。target和Action都可以是离散的或者连续的。）\n\n2. 深度学习作为用梯度下降算法优化的模型，无法优化对loss不可导的参数。如在深度学习中，设计一个分支来决定模型是否应该包含某个模块，这个分支的参数是不可优化的。因为包含和不包含是离散的，对loss不可导。\n\n   不过假设，如果包含与不包含是连续的。也就是说，可以以0.1的权重包含。那么，这些参数是可以优化的。从这点来看，离散就是导致模型参数不可优化的原因。\n\n3. 强化学习在离散的情况下解决2中的问题。由此，我得到了一个概念，强化学习解决离散的问题。\n\n4. 下面我们来分析一下这个场景。首先，决定一个模块该不该被使用，这个场景是一次Action的场景，不是连续决策的场景。也就是说Action一次，我就能知道最终reward多少了，只有单步的reward。\n\n   限于这个单次决策的场景来看，如果Action相对于reward是连续可导的，那么深度学习就能解决这个问题。如果Action相对于reward是离散的，那么仅仅深度学习无法解决这个问题，要靠强化学习。\n\n   <font color=green>这里单次Action就知道reward，实际上这个问题就退化为了有监督学习，因为这个单步的reward就可以看成我的标签了。所以深度学习解决这个问题是很自然的。</font>\n\n5. 多次决策的问题，无论是连续的还是离散的都只能用强化学习的方法。因为多次决策，这个问题就不可以退化为监督学习的问题了。它是一个真正的强化学习的问题。\n\n   \n\n综上所诉，强化学习解决深度学习解决不了的离散问题，那只是在单次决策的时候，这个问题退化为了有监督学习。强化学习的方法，恰好可以提供离散变量的学习。\n\n强化学习方法解决深度学习中的离散问题，仅仅是强化学习附带的一个小福利。\n\n**<font color=green>因为它能把经验转化为可导的目标，就拿策略网络来说，从梯度的角度，它只管增加当前随机Action的概率，而加入advatage之后，自动就优化除了想要的大reward的行为。</font>**\n\n## 深度学习优化和强化学习优化的感性理解\n\n前面说了深度学习优化可导的参数，强化学习可以优化不可导的参数。这里说一下对深度学习优化方法和强化学习优化方法的感性理解。\n\n还是说前面包不会包含某模块的例子，由于连续可导，对于每一个参数值，深度学习模型其实都同时参与了两种Action（包含和不包含）。score = 0.1 包含，其实其中包含了含有的成分，也包含了不含有的成分。所以我们可以连续的变动score，看看包含多好，还是不好含多好。这其实就是梯度下降算法的方式。得益于每一个参数，其实我都对包含和不包含的情况都有了解，我当然知道哪个更好，就往那边移动（优化）。\n\n然而，对于离散的情况，要么只能包含，要么只能不包含。当选择包含的时候，模型对不包含的情况完全是无知的。可能更好，也可能差。当不包含的时候，也是一样的。无论哪种情况，我都没有办法优化，两种情况是完全隔离开的，信息不沟通的，是离散的。所以梯度下降算法无法优化它。\n\n强化学习用随机探索的方法让两者信息又沟通起来。包含一下试一下，然后，不包含也试一下。尝试的结果是哪种reward多，就增大哪种的概率。\n\n**<font color=green>所以，无论哪种优化方法，信息的沟通都是必要的。要对所有的action都了解，才能知道选择哪种action。 只是深度学习是连续的，它的每一种参数，都包含了所有Action的信息（reward），每一种Action都参与了，所以它能直接连续的梯度下降的优化，不需要随机探索了。而对于离散的，每种action只能知道自己的reward，对其他Action一无所知的时候，梯度的优化是不行的。必须要探索各种Action，还是要知道了每一种Action的情况(reward)之后，才能优化。这是方法论。</font>**\n\n更进一步，离散的地方，相对于reward一定是不可导的，所以深度学习不行。而强化学习，更准确的说是策略网络，相当于给离散的地方加了标签，这样它就在离散的地方有监督了，它就可以根据增加的标签优化。而标签的设计就是根据探索的结果，增大reward大的Action，reward大的Action就是它的标签，而且这个标签是动态的，是对抗得出的。\n\n强化学习方法算出的梯度是策略梯度。\n\n**<font color=green>强化学习： 不知道选哪边了； 试试呗；按试出来reward大的Action优化它。</font>**\n\n**<font color=green>强化学习：它离散，对于reward不可导；不直接用reward优化它，给它加个标签，把试出来reward大的Action，作为标签去优化</font>**\n\n在不可导的地方加标签。\n\n**<font color=green>由此，强化学习算法的本质是制作标签，无论是连续决策，标签不确定的情况，还是它能解决离散问题的情况，它都是用制作标签的方法解决的。</font>**\n\n# 策略网络(Policy Network)和估值网络(Value Network)\n\nAlphaGo 使用了快速走子，策略网络，估值网络和蒙特卡洛搜索树等技术。\n\n强化学习算法的一个关键是<font color=green>随机性和探索性</font>，我们需要让算法通过试验样本自己学习什么才是某个环境状态下比较好的Action，而不是像有监督学习一样，告诉模型什么是好的Action，因为我们也不知道什么是好的Action.\n\n深度强化学习模型的本质是神经网络，神经网络是工具，根据问题转化以及建模的不同，主要分为策略网络和估值网络。\n\n强化学习中最重要的两类方法**Policy-based,Value-based**。第一种直接预测在某个环境下应该采取的行动（直接输出改采取Action的概率）。第二种预测在某个环境下所有行动的期望价值，然后通过选择q值最高的行动执行策略。\n\n他们都能完成决策，但由于建模的不同，估值网络包含有更多的信息，它不仅能提供决策，还预测了决策带来的收益。\n\n<font color=red>策略网络是隐式的学习了某一Action所带来的全部获益（当前获益+后续获益），而估值网络直接显示的学习Action所带来的全部获益。</font>强化学习算法做出最佳抉择只需要知道哪个Action全部获益最大，策略网络就是这样做的，估值网络不仅学习了哪个Action全部获益最大，还把每个Action的全部获益给计算出来了。\n\n<font color=green>相对来说，策略网络的性能会比估值网络好一些。</font>\n\n<font color=green>Value Based方法适合仅有少量Action的环境，而Policy Based方法更通用，适合Action种类非常多，或者具有连续取值的Action的环境。结合了深度学习之后，Policy Based方法就变成了策略网络，Value Based方法就变成了估值网络。</font>\n\n## 策略网络(Policy Network)\n\n直接看一个例子，学习的目标是，左右用力使得木棍不倒地，[Policy_Network.py](https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py)\n\n关键代码\n\n ```python\n score = tf.matmul(layer1,W2)\n probability = tf.nn.sigmoid(score)#网络输出采取Action 1的概率。\n input_y = tf.placeholder(tf.float32,[None,1], \\\\\n                          name=\"input_y\")# 输入采取过的行为，这个行为是随机生成的。\n advantages = tf.placeholder(tf.float32,name=\"reward_signal\") \n # 输入获益\n loglik = tf.log(input_y*(input_y - probability) + \\\\\n                 (1 - input_y)*(input_y + probability)) \n # 损失函数，如果行为是1，则增大\n \n #概率，如果行为是 0，则减小概率（相当于也是增加0的概率），也就是说这个损\n #失函数无论当前行为是什么都会增大当前行为的概率。\n loss = -tf.reduce_mean(loglik * advantages) # 这行代码很关键，\n #相当于给损失函数成了一个权重advantages，得到最终的损失函数。\n #advantages是当前试验的全部获益。如果全部获益大，将以更大的权重，增加 \n #当前行为的概率。\n \n #所以，策略网络其实也是一个对抗学习的过程，增加所有采取过行为的概率，只是\n #获益多的行为以更大的权重增加。\n \n ## 一个试验： 由初始状态开始，随机采取一连串的行为\n #（Policy_Network.py 中是根据当前模型输出的概率,来生成随机的行为，但\n #是我感觉直接用0.5的概率随机生成一连串的0和1的行为也是可以的，下面将实\n #验一下），直到任务结束。\n \n ## 由于每个试验，都可以一直行为到任务结束，所以每个action，我们都可以得\n #到它在该试验中的全部获益（当前获益 + 之后所有行为的获益）\n \n ## 随机生成了n个试验，其中又各种各样的决策（随机探索），全部获益大的\n #action，它的advantages也大，那么它的概率就增大的多，它被强化的厉害。\n \n ## 试验生成的过程，实际上就是数据集构建的过程。策略网络的数据集是由环境\n #和一系列随机的行为构成的。它提供了环境在各种行为下的反应（获益）。模型\n #学习为环境带来高获益的行为的规律。\n ```\n\n由上面的代码可知，从策略网络的角度看强化学习的话，强化学习的关键其实是对数据集的构建---如何构建数据集。\n\n在构建数据集的时候，随机探索肯定是必要的。随机探索的结果会得到一系列好的行为，也会得到一系列不好的行为。如何强化好的行为就是算法设计的时候需要注意的。\n\n上面的代码在探索阶段借用了当前的模型，即根据当前模型输出的概率随机生成行为，从而形成数据集。如果完全的随机（一直使用0.5的概率随机的生成Action）会什么样呢？\n\n### 数据集是否可以和模型无关（不随着模型变化）？\n\n关键修改代码\n\n```python\n#基于当前模型，根据当前的状态x，生成Action 1的概率\ntfprob = sess.run(probability,feed_dict={observations: x})\n# 基于预测概率，随机生成行为，并试探环境。生成数据集。\naction = 1 if np.random.uniform() < tfprob else 0\n```\n\n修改后\n\n```python\n# 注释掉这句，并不需要根据当前模型生成概率\n# tfprob = sess.run(probability,feed_dict={observations: x})\n# 直接设置概率为0.5，随机完全随机探索生成数据集。\ntfprob = 0.5\naction = 1 if np.random.uniform() < tfprob else 0\n```\n\n结果：修改后，模型无法收敛。\n\n完全随机很小的概率能探索出很好的试验，这些好的行为也很难持续的得到强化。\n\n所以，强化学习也有一种效果叠加的感觉。在完全随机的情况下 ，探索出相对好的action，再在这个相对好的action的基础上，在探索探索出更好的action。\n\n如果数据集不依赖模型，就是一直在完全随机的基础上探索。这样很难收敛。\n\n也可以这样看，完全随机的话，最多能学到前几步的策略（因为完全随机就走不了几步，探索的经验就只有那几步）。依赖于模型，探索的行为更有价值，因为是依赖于学到过的知识的，一方面确认了，按学到的知识走，确实获益多，一方面又在学到的知识的基础上，做了一些随机，探索更好的知识。\n\n## 估值网络(Value Network，Q-learning)\n\nQ-Learing用神经网络实现，得到的模型就是估值网络。\n\n也看一个例子，[Value_Network.py](https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py)\n\n学习每个Action所对应的reward的期望。\n\n我们先看看数据集的结构\n\n```python\n#Save the experience to our episode buffer.\nepisodeBuffer.add(np.reshape(np.array([s,a,r,s1,d]),[1,5]))\n# 其中s是当前时刻的环境状态，a是当前随机采取的Action，r是这个Action的当前reward\n# s1是采取Action之后的下一状态，d是布尔型表示是否任务结束。  \n```\n\n1. 现在目标是学习Q(s<sub>t</sub>, a<sub>t</sub>)，也就是当前环境状态，采取行为a的全部reward的期望。\n\n2. 现在假设我们有模型Q<sub>desird</sub>，可以预测全部reward了，那么这个模型应该满足条件，Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，这有点递归的感觉了。\n\n3. 现在我们能不能根据这个公式 ， 来优化出Q<sub>desired</sub>。肯定是能的。对于探索过的所有试验，公式都满足的话，此时的模型就可以看成我们想要的模型了。我感觉这就是估值网络方法的核心。\n\n   \n\n直接看关键代码\n\n```python\n#Choose an action by greedily (with e chance of random action)\n# from the Q-network\nif np.random.rand(1) < e or total_steps < pre_train_steps:\n    a = np.random.randint(0,4)\nelse:\n    a = sess.run(mainQN.predict,feed_dict={mainQN.scalarInput:[s]})[0]\n# 这段代码其实是探索的代码，当最开始的时候是完全随机探索（total_steps < pre_train_steps的时候）\n# 当total_steps >= pre_train_steps之后呢，就不是完全随机探索了。\n# 有e的概率是随机探索的，（1-e）的概率是由训练好的模型决定之后的Action。 \n# 这里是估值网络和策略网络的不同，策略网络本身就具有随机性，所以不需要引入\n# 额外的参数e和pre_train_steps来控制随机探索的强度。\n# 策略网络在训练的过程中，本身就是由随机性大，到慢慢的收敛到好的Action\n# 所以可以直接得到好的探索的训练样本。估值网络没有这样好的性质，它连\n# 随机性都没有，就需要人为的制造，满足从完全随机探索，到在好的Action的\n# 基础上具有一定的随机性进行探索。\n```\n\n**这是策略网络和估值网络的共通之处，其实这也最上面那个注释\"by greedily (with e chance of random action) from the Q-network\"的意思。**\n\n**<font color=green>“贪心”两个字完美的诠释了强化学习，无论是策略网络还是估值网络，在探索阶段，在生成数据集上的特点。</font>**\n\n在策略网络那一节，我做的那个试验，和模型无关生成数据集。其实就是不贪心了，不贪心不行。\n\n```python\nif total_steps > pre_train_steps:\n    if e > endE:\n        e -= stepDrop\n# 完全随机了之后，开始慢慢减小随机性。\n# 模型约不可靠的时候，探索性和随机性越强。后来模型慢慢变得可靠就减弱随机性。\n# 因为模型越来越可靠的时候，随机性大就会得到很多远远低于当前模型性能的试验\n# 这些试验都是早就被pass了的，学不到什么东西，损坏模型的探索。\n# endE=0.1 说明无论训练的多好，模型都保持了随机性，保持了探索性\n#　人永远要有好奇心，永远要觉得自己的知识还可能不是最好的\n```\n\n\n\n下面的代码是将在数据集弄好的情况下，如何训练模型的。\n\n```python \nif total_steps % (update_freq) == 0:\n    trainBatch = myBuffer.sample(batch_size) #Get a random batch of experiences.\n    #Below we perform the Double-DQN update to the target Q-values\n    # 主网络预测了下一刻需要采取的Action，trainBatch[:,3]是当前的下一刻的环境\n    # 回顾公式，Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)\n    # 这里主函数预测的Action就是t+1时刻（下一时刻）获益值最大的Action\n    Q1 = sess.run(mainQN.predict,feed_dict={mainQN.scalarInput:np.vstack(trainBatch[:,3])})\n    # target网络预测了下一时刻的reward\n    Q2 = sess.run(targetQN.Qout,feed_dict={targetQN.scalarInput:np.vstack(trainBatch[:,3])})\n    end_multiplier = -(trainBatch[:,4] - 1)\n    # 用主网络预测出的Action以及target网络预测出的所有行为的reward\n    # 选择了最大的reward,也就是公式中的 Max Q(s_t+1, a)\n    doubleQ = Q2[range(batch_size),Q1]\n    # 这里得到的就是公式Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)\n    # 的右边，当前reward加上乘以衰减系数之后的，下一步最大reward\n    targetQ = trainBatch[:,2] + (y*doubleQ * end_multiplier)\n    #Update the network with our target values.\n    # 公式右边得到了之后，在把真正的当前状态输入进去，得到左边\n    # 左边以右边作为标签进行学习。更新主网络的参数\n    _ = sess.run(mainQN.updateModel, \\\n                 feed_dict={mainQN.scalarInput:np.vstack(trainBatch[:,0]),mainQN.targetQ:targetQ, mainQN.actions:trainBatch[:,1]})\n    # 更新target网络的参数。\n    updateTarget(targetOps,sess) #Update the target network toward the primary network.\n```\n\n\n\ntarget网络参数的更新方式代码\n\n```python \ndef updateTargetGraph(tfVars,tau):\n    total_vars = len(tfVars)\n    op_holder = [] \n    # 主网络是和target网络一样的，前一半参数正好是主网络的参数\n    for idx,var in enumerate(tfVars[0:total_vars//2]):\n        # idx+total_vars对应的时候后一半的参数也就是target网络的参数\n        # 这里相当于是target参数 = 主网络参数 * tau + （1- tau）*target参数\n        # 也就是说target网络在以一定的速度向主网络靠近\n        # 结合前面的代码，主网络才是真正学习的网络，target网络的作用仅仅是得到等式\n        # 右边的值，即标签，即使是等式右边，也不是target网络完全决定的\n        # target网络得到了所有Action的reward，最大的Action是主网络选择的\n        # 为什么要这么做，target网络也是在模仿主网络，只用主网络也能得到等式的右边\n        # 理论上其实右边也应该是主网络决定，现在搞了个主网络的模仿者target网络\n        # 是出于优化的考虑。我们后面叙述。\n        op_holder.append(tfVars[idx+total_vars//2].assign\\\\\n                         ((var.value()*tau) \\\\\n                      + ((1-tau)*tfVars[idx+total_vars//2].value())))\n        return op_holder\n\n    def updateTarget(op_holder,sess):\n        for op in op_holder:\n            sess.run(op)\n\n```\n\n现在其实我们把关键的代码都看了，在这段代码实现中，引入了一些state of the art的trick，下面我们结合看过的代码在提一遍。\n\n1. 引入卷积层，这段代码比较简单，我们没有看。环境状态是用图片的形式给的，用CNN提取特征是比较自然的。\n2. Experience replay。估值网络不像策略网络一样得到试验之后，用一次就扔掉再去制作新的试验（数据集）来训练。它把每次试验都放在一个试验池里面。试验池长度为N，如果超过了N，那就把最老的试验样本扔掉。每次 训练的时候从试验池里面随机选择batchsize个样本进行训练，保持了对样本的利用率，同时其实也增加了模型的稳定性，因为数据集是相对稳定的（相比于N=1而言，每次训练了就扔掉，进来的都是新的，不那么稳定）。\n3. 使用target网络来辅助训练。**之所以要用target网络来制造训练目标，用主网络来实际训练，是为了让Q-Learing训练的目标保持平稳。**强化学习不像普通的监督学习，它的目标是变化的，**因为学习目标的一部分就是模型本身输出的。**每次更新模型参数都会导致学习目标发生变化，如果更新频繁，幅度很大，我们的训练过程就会变得非常不稳定并且失控。**DQN的训练会陷入目标Q与预测Q的反馈循环中，震荡发散。**所以用target网络来制造目标，target网络和主网络又不是矛盾的，因为target网络会逼近主网络，它是主网络的模仿者，所以它提供的目标Q也是有权威的。\n4. Double DQN。这个trick源于target网络选的最大Action不准。模仿的不够好，现在就让主网络来帮它选。也就是上面代码中我们看过了主网络输出action，选择target网络输出的reward，得到公式的右边。\n5. Dueling DQN。上代码\n\n```python \nself.AW = tf.Variable(xavier_init([h_size//2,env.actions]))\nself.VW = tf.Variable(xavier_init([h_size//2,1]))\nself.Advantage = tf.matmul(self.streamA,self.AW)\nself.Value = tf.matmul(self.streamV,self.VW)\n\n#Then combine them together to get our final Q-values.\n# 看这里Qout是网络最终预测的所有Action的reward。它由两部分组成Value和Advantage\n# 由最上面两行可以看出Value是一维的，是实数，advantage是#action维度的向量\n# 所以，Dueling DQN就是将reward裁成了两部分，一部分是环境状态本身具有的价值Value\n# 另一部分就是Action本身具有的价值，相加起来就是在这个环境下Action具有的价值。\n# 其实我感觉这些解释都是人为的，具体是不是这样谁也不知道，可能只是这样优化的好。\n#　因为即使不分为两部分，网络输出Ｑout的时候，输入也是环境状态，肯定都会把环境考虑\n# 进去才有Action的价值。然而直接输出这个价值，发现优化的不好，分为两部分之后，发现\n# 优化的好了。其实谁也不知道其中到底是什么原因起作用。\nself.Qout = self.Value + tf.subtract(self.Advantage,tf.reduce_mean(self.Advantage,axis=1,keep_dims=True))\n```\n\n\n\n# 回顾\n\n强化学习的本质是连续决策。强化学习算法的关键是标签制作，数据集制作。\n\n连续决策问题是没有确定的标签的，它通过探索试验得到数据集和标签，为没有提供标签的问题，做了标签，让问题可以解决。\n\n深度学习无法优化离散的不可导的参数，强化学习也可以通过在离散的地方做数据集做标签，把它转换为可导的，可用sgd优化的问题。\n\n做标签和数据集的关键是随机性以及贪心，贪心让它立足于以往的知识，随机让它不刚愎自用，保持谦卑，给新的可能保留空间。\n\n\n\n无论是策略网络还是估值网络，在数据集的制作上都是一样的，随机性和贪心。估值网络的数据集制作，可以看出强化学习探索的本质（由于估值网络本身没有随机性，它在制作数据集的时候，显示的暴露了，探索和贪心的本质。策略网络这方面还不太好看出来，因为它是隐式的利用探索和贪心）。\n\n\n\n策略网络，增大所有行为的概率，但是对于reward大 的行为增大的权重大。这个思路在我得感觉上更加符合强化两个字。强化好的行为嘛。\n\n估值网络的本质是公式Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，有点递归的感觉。\n\n策略网络和估值网络数据集也有一点不同，策略网络的数据集是纵向的，一串行为一起的。而估值网络的数据集是单个单个的。\n\n由下面代码可以看出，策略网络中，每一窜试验就会训练一次，只是网络参数更新会积累了好几次试验之后才更新。策略网络关心从开始到结束一系列行为。而估值网络只关心当前和下一状态。\n\n```python \nif done:\n    episode_number += 1\n    epx = np.vstack(xs)\n    epy = np.vstack(ys)\n    epr = np.vstack(drs)\n    tfp = tfps\n    xs,hs,dlogps,drs,ys,tfps = [],[],[],[],[],[]\n\n    discounted_epr = discount_rewards(epr)\n    discounted_epr -= np.mean(discounted_epr)\n    discounted_epr //= np.std(discounted_epr)\n\n    tGrad = sess.run(newGrads,feed_dict={observations: epx, input_y: epy, advantages: discounted_epr})\n    for ix,grad in enumerate(tGrad):\n        gradBuffer[ix] += grad\n\n        if episode_number % batch_size == 0:\n            sess.run(updateGrads,feed_dict={W1Grad: gradBuffer[0],W1_1Grad:gradBuffer[1],W2Grad:gradBuffer[2]})\n```\n\n估值网络人为的控制随机强度，也是一个值得考虑的问题。\n\n\n\n","source":"_posts/First-Step-to-RL.md","raw":"---\ntitle: First Step to Reinforcement Learing\ndate: 2021-12-03 16:48:41\ntags:\n- Reinforcement Learning\ncategories:\n- Reinforcement Learning\n\n\n---\n\n\n\n强化学习的入门介绍\n\n什么是强化学习\n\n深度强化学习算法：策略网络(Policy Network)和估值网络(Value Network)\n\n<!-- more -->\n\n# 什么是强化学习，关于强化学习的几点疑问\n\n<font color=green size=3>强化学习三要素：环境状态，行动，奖励</font>\n\n<font color=green size=3>目标：尽量多的获得奖励</font>\n\n<font color=green size=3>本质：连续决策</font>\n\n基本的强化学习模型包括：\n\n* 环境状态的集合S\n* 动作的集合A\n* 状态之间的转换规则（是环境的一部分）\n* 规定转换后“即时奖励”的规则（是环境的一部分）\n* 描述主体（智能体）能够观察到什么的规则（是环境的一部分）\n* 能够做出决策/动作的主体（智能体）\n\n## 区别于深度学习，强化学习的本质特点是什么？\n\n**两个定义**\n\n1，强化学习是机器学习的一个重要分支，主要用来解决连续决策问题。\n\n2，强化学习又称 再励学习，评价学习或增强学习，是机器学习的范式和方法论之一，用于描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。\n\n强化学习的本质是<font color=red> 描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。</font>它本质是这样一种场景，在这种场景中它为了达到某种目的，做出连续的决策。这样符合这种场景，那就是强化学习。\n\n强化学习和深度学习这两个名词的维度是不一样的。深度学习描述的是算法本身的特点，深度够不够，是不是连接主义的模型。深度学习可以用来做无监督，也可以用来做半监督，也可以用来做弱监督，甚至可以用来作为强化学习算法的一部分。深度学习这个名词，不管应用场景只管模型本身是不是满足深度学习的特点。\n\n而强化学习描述的是应用场景的特点，只要能提供智能体决策的算法，管它是什么模型，什么结构，那就是强化学习的算法。从这个角度上讲，我现在认为强化学习和监督学习，无监督学习，弱监督学习，是并列的，是对应用场景的描述。和深度学习不是同一维度的。\n\n<font color=red>强化学习的本质在于目标给定的形式，不像无监督学习那样完全没有学习目标，也不像监督学习那样有非常明确的目标（label），强化学习的目标一般是变化的，不明确的，甚至可能不存在绝对正确的目标。，强化学习的问题都可以抽象成，环境状态，行动和奖励。应该说只要能抽象为这三个要素，目标是获得最大奖励的模型，就是强化学习的模型。</font>\n\n强化学习的最大的特点是“试错”，是尝试各种可能，而强化结果好的可能。（策略网络的特点，估值网络的特点是修正和预测获益）\n\n由于强化学习是一种决策学习，这个问题的特点就是离散型。但是离散并不就是强化学习（连续的决策才是，目标的模糊和不确定性是决策问题的特点）。深度学习本质是函数的拟合，所以连续可微是它的特点。并不能说连续可微的问题就是深度学习，离散的问题就是强化学习。 \n\n## 深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\n\n这个问题要了解下一节，具体的强化学习方法。\n\n## 强化学习与弱监督学习？\n\n弱监督是属于有监督学习，只是它学习的目标不是被给予的标签，而是比被给予标签更强的标签（强弱是指标签做含有的信息量），也就是说弱监督是根据少量信息的标签，推测出更多的信息。\n\n强化学习的本质是连续决策。连续决策的特点是目标的模糊和不确定性。\n\n所以，虽然弱监督和强化学习都没有给出最终准确的目标，但是他们任然很不同的\n\n## 深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\n\n深度学习大部分我们用作有监督的学习算法。其实说深度学习是死的，不如说有监督学习是死的。\n\n有监督学习其实是完全的复刻标签里面含有的知识，它的本质就是一个函数拟合的问题，它无法摆脱对绝对的标签的依赖，无法超越标签。\n\n而强化学习，正由于它的目标是模糊和不确定的。使得算法在设计上必须具有随机性和探索性，它能够探索出人类从来没有到过的领域。就像在围棋上，下出人类完全无法理解的棋，人从来没有想过的一些下法。这就是强化学习算法探索出来的知识。所以我觉得它是活着的，拥有智能的算法。\n\n<font color=green>从感性的层面，强化学习算法很接近人脑的行为：感知环境，探索环境，强化有益行为</font>\n\n## 关于深度学习，强化学习，连续可导性和离散不可导性的讨论\n\n1. 从函数的角度，深度学习和强化学习都需要学习一个函数映射。深度学习是从输入到target的映射。强化学习是学从环境状态到Action的映射。这两个映射可以看成性质一样的，因为深度学习可以作为强化学习的智能体。所以从函数的角度，他们没有连续和离散的区别。（PS. 深度学习模型和强化学习的智能体都是连续可导的函数。target和Action都可以是离散的或者连续的。）\n\n2. 深度学习作为用梯度下降算法优化的模型，无法优化对loss不可导的参数。如在深度学习中，设计一个分支来决定模型是否应该包含某个模块，这个分支的参数是不可优化的。因为包含和不包含是离散的，对loss不可导。\n\n   不过假设，如果包含与不包含是连续的。也就是说，可以以0.1的权重包含。那么，这些参数是可以优化的。从这点来看，离散就是导致模型参数不可优化的原因。\n\n3. 强化学习在离散的情况下解决2中的问题。由此，我得到了一个概念，强化学习解决离散的问题。\n\n4. 下面我们来分析一下这个场景。首先，决定一个模块该不该被使用，这个场景是一次Action的场景，不是连续决策的场景。也就是说Action一次，我就能知道最终reward多少了，只有单步的reward。\n\n   限于这个单次决策的场景来看，如果Action相对于reward是连续可导的，那么深度学习就能解决这个问题。如果Action相对于reward是离散的，那么仅仅深度学习无法解决这个问题，要靠强化学习。\n\n   <font color=green>这里单次Action就知道reward，实际上这个问题就退化为了有监督学习，因为这个单步的reward就可以看成我的标签了。所以深度学习解决这个问题是很自然的。</font>\n\n5. 多次决策的问题，无论是连续的还是离散的都只能用强化学习的方法。因为多次决策，这个问题就不可以退化为监督学习的问题了。它是一个真正的强化学习的问题。\n\n   \n\n综上所诉，强化学习解决深度学习解决不了的离散问题，那只是在单次决策的时候，这个问题退化为了有监督学习。强化学习的方法，恰好可以提供离散变量的学习。\n\n强化学习方法解决深度学习中的离散问题，仅仅是强化学习附带的一个小福利。\n\n**<font color=green>因为它能把经验转化为可导的目标，就拿策略网络来说，从梯度的角度，它只管增加当前随机Action的概率，而加入advatage之后，自动就优化除了想要的大reward的行为。</font>**\n\n## 深度学习优化和强化学习优化的感性理解\n\n前面说了深度学习优化可导的参数，强化学习可以优化不可导的参数。这里说一下对深度学习优化方法和强化学习优化方法的感性理解。\n\n还是说前面包不会包含某模块的例子，由于连续可导，对于每一个参数值，深度学习模型其实都同时参与了两种Action（包含和不包含）。score = 0.1 包含，其实其中包含了含有的成分，也包含了不含有的成分。所以我们可以连续的变动score，看看包含多好，还是不好含多好。这其实就是梯度下降算法的方式。得益于每一个参数，其实我都对包含和不包含的情况都有了解，我当然知道哪个更好，就往那边移动（优化）。\n\n然而，对于离散的情况，要么只能包含，要么只能不包含。当选择包含的时候，模型对不包含的情况完全是无知的。可能更好，也可能差。当不包含的时候，也是一样的。无论哪种情况，我都没有办法优化，两种情况是完全隔离开的，信息不沟通的，是离散的。所以梯度下降算法无法优化它。\n\n强化学习用随机探索的方法让两者信息又沟通起来。包含一下试一下，然后，不包含也试一下。尝试的结果是哪种reward多，就增大哪种的概率。\n\n**<font color=green>所以，无论哪种优化方法，信息的沟通都是必要的。要对所有的action都了解，才能知道选择哪种action。 只是深度学习是连续的，它的每一种参数，都包含了所有Action的信息（reward），每一种Action都参与了，所以它能直接连续的梯度下降的优化，不需要随机探索了。而对于离散的，每种action只能知道自己的reward，对其他Action一无所知的时候，梯度的优化是不行的。必须要探索各种Action，还是要知道了每一种Action的情况(reward)之后，才能优化。这是方法论。</font>**\n\n更进一步，离散的地方，相对于reward一定是不可导的，所以深度学习不行。而强化学习，更准确的说是策略网络，相当于给离散的地方加了标签，这样它就在离散的地方有监督了，它就可以根据增加的标签优化。而标签的设计就是根据探索的结果，增大reward大的Action，reward大的Action就是它的标签，而且这个标签是动态的，是对抗得出的。\n\n强化学习方法算出的梯度是策略梯度。\n\n**<font color=green>强化学习： 不知道选哪边了； 试试呗；按试出来reward大的Action优化它。</font>**\n\n**<font color=green>强化学习：它离散，对于reward不可导；不直接用reward优化它，给它加个标签，把试出来reward大的Action，作为标签去优化</font>**\n\n在不可导的地方加标签。\n\n**<font color=green>由此，强化学习算法的本质是制作标签，无论是连续决策，标签不确定的情况，还是它能解决离散问题的情况，它都是用制作标签的方法解决的。</font>**\n\n# 策略网络(Policy Network)和估值网络(Value Network)\n\nAlphaGo 使用了快速走子，策略网络，估值网络和蒙特卡洛搜索树等技术。\n\n强化学习算法的一个关键是<font color=green>随机性和探索性</font>，我们需要让算法通过试验样本自己学习什么才是某个环境状态下比较好的Action，而不是像有监督学习一样，告诉模型什么是好的Action，因为我们也不知道什么是好的Action.\n\n深度强化学习模型的本质是神经网络，神经网络是工具，根据问题转化以及建模的不同，主要分为策略网络和估值网络。\n\n强化学习中最重要的两类方法**Policy-based,Value-based**。第一种直接预测在某个环境下应该采取的行动（直接输出改采取Action的概率）。第二种预测在某个环境下所有行动的期望价值，然后通过选择q值最高的行动执行策略。\n\n他们都能完成决策，但由于建模的不同，估值网络包含有更多的信息，它不仅能提供决策，还预测了决策带来的收益。\n\n<font color=red>策略网络是隐式的学习了某一Action所带来的全部获益（当前获益+后续获益），而估值网络直接显示的学习Action所带来的全部获益。</font>强化学习算法做出最佳抉择只需要知道哪个Action全部获益最大，策略网络就是这样做的，估值网络不仅学习了哪个Action全部获益最大，还把每个Action的全部获益给计算出来了。\n\n<font color=green>相对来说，策略网络的性能会比估值网络好一些。</font>\n\n<font color=green>Value Based方法适合仅有少量Action的环境，而Policy Based方法更通用，适合Action种类非常多，或者具有连续取值的Action的环境。结合了深度学习之后，Policy Based方法就变成了策略网络，Value Based方法就变成了估值网络。</font>\n\n## 策略网络(Policy Network)\n\n直接看一个例子，学习的目标是，左右用力使得木棍不倒地，[Policy_Network.py](https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py)\n\n关键代码\n\n ```python\n score = tf.matmul(layer1,W2)\n probability = tf.nn.sigmoid(score)#网络输出采取Action 1的概率。\n input_y = tf.placeholder(tf.float32,[None,1], \\\\\n                          name=\"input_y\")# 输入采取过的行为，这个行为是随机生成的。\n advantages = tf.placeholder(tf.float32,name=\"reward_signal\") \n # 输入获益\n loglik = tf.log(input_y*(input_y - probability) + \\\\\n                 (1 - input_y)*(input_y + probability)) \n # 损失函数，如果行为是1，则增大\n \n #概率，如果行为是 0，则减小概率（相当于也是增加0的概率），也就是说这个损\n #失函数无论当前行为是什么都会增大当前行为的概率。\n loss = -tf.reduce_mean(loglik * advantages) # 这行代码很关键，\n #相当于给损失函数成了一个权重advantages，得到最终的损失函数。\n #advantages是当前试验的全部获益。如果全部获益大，将以更大的权重，增加 \n #当前行为的概率。\n \n #所以，策略网络其实也是一个对抗学习的过程，增加所有采取过行为的概率，只是\n #获益多的行为以更大的权重增加。\n \n ## 一个试验： 由初始状态开始，随机采取一连串的行为\n #（Policy_Network.py 中是根据当前模型输出的概率,来生成随机的行为，但\n #是我感觉直接用0.5的概率随机生成一连串的0和1的行为也是可以的，下面将实\n #验一下），直到任务结束。\n \n ## 由于每个试验，都可以一直行为到任务结束，所以每个action，我们都可以得\n #到它在该试验中的全部获益（当前获益 + 之后所有行为的获益）\n \n ## 随机生成了n个试验，其中又各种各样的决策（随机探索），全部获益大的\n #action，它的advantages也大，那么它的概率就增大的多，它被强化的厉害。\n \n ## 试验生成的过程，实际上就是数据集构建的过程。策略网络的数据集是由环境\n #和一系列随机的行为构成的。它提供了环境在各种行为下的反应（获益）。模型\n #学习为环境带来高获益的行为的规律。\n ```\n\n由上面的代码可知，从策略网络的角度看强化学习的话，强化学习的关键其实是对数据集的构建---如何构建数据集。\n\n在构建数据集的时候，随机探索肯定是必要的。随机探索的结果会得到一系列好的行为，也会得到一系列不好的行为。如何强化好的行为就是算法设计的时候需要注意的。\n\n上面的代码在探索阶段借用了当前的模型，即根据当前模型输出的概率随机生成行为，从而形成数据集。如果完全的随机（一直使用0.5的概率随机的生成Action）会什么样呢？\n\n### 数据集是否可以和模型无关（不随着模型变化）？\n\n关键修改代码\n\n```python\n#基于当前模型，根据当前的状态x，生成Action 1的概率\ntfprob = sess.run(probability,feed_dict={observations: x})\n# 基于预测概率，随机生成行为，并试探环境。生成数据集。\naction = 1 if np.random.uniform() < tfprob else 0\n```\n\n修改后\n\n```python\n# 注释掉这句，并不需要根据当前模型生成概率\n# tfprob = sess.run(probability,feed_dict={observations: x})\n# 直接设置概率为0.5，随机完全随机探索生成数据集。\ntfprob = 0.5\naction = 1 if np.random.uniform() < tfprob else 0\n```\n\n结果：修改后，模型无法收敛。\n\n完全随机很小的概率能探索出很好的试验，这些好的行为也很难持续的得到强化。\n\n所以，强化学习也有一种效果叠加的感觉。在完全随机的情况下 ，探索出相对好的action，再在这个相对好的action的基础上，在探索探索出更好的action。\n\n如果数据集不依赖模型，就是一直在完全随机的基础上探索。这样很难收敛。\n\n也可以这样看，完全随机的话，最多能学到前几步的策略（因为完全随机就走不了几步，探索的经验就只有那几步）。依赖于模型，探索的行为更有价值，因为是依赖于学到过的知识的，一方面确认了，按学到的知识走，确实获益多，一方面又在学到的知识的基础上，做了一些随机，探索更好的知识。\n\n## 估值网络(Value Network，Q-learning)\n\nQ-Learing用神经网络实现，得到的模型就是估值网络。\n\n也看一个例子，[Value_Network.py](https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py)\n\n学习每个Action所对应的reward的期望。\n\n我们先看看数据集的结构\n\n```python\n#Save the experience to our episode buffer.\nepisodeBuffer.add(np.reshape(np.array([s,a,r,s1,d]),[1,5]))\n# 其中s是当前时刻的环境状态，a是当前随机采取的Action，r是这个Action的当前reward\n# s1是采取Action之后的下一状态，d是布尔型表示是否任务结束。  \n```\n\n1. 现在目标是学习Q(s<sub>t</sub>, a<sub>t</sub>)，也就是当前环境状态，采取行为a的全部reward的期望。\n\n2. 现在假设我们有模型Q<sub>desird</sub>，可以预测全部reward了，那么这个模型应该满足条件，Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，这有点递归的感觉了。\n\n3. 现在我们能不能根据这个公式 ， 来优化出Q<sub>desired</sub>。肯定是能的。对于探索过的所有试验，公式都满足的话，此时的模型就可以看成我们想要的模型了。我感觉这就是估值网络方法的核心。\n\n   \n\n直接看关键代码\n\n```python\n#Choose an action by greedily (with e chance of random action)\n# from the Q-network\nif np.random.rand(1) < e or total_steps < pre_train_steps:\n    a = np.random.randint(0,4)\nelse:\n    a = sess.run(mainQN.predict,feed_dict={mainQN.scalarInput:[s]})[0]\n# 这段代码其实是探索的代码，当最开始的时候是完全随机探索（total_steps < pre_train_steps的时候）\n# 当total_steps >= pre_train_steps之后呢，就不是完全随机探索了。\n# 有e的概率是随机探索的，（1-e）的概率是由训练好的模型决定之后的Action。 \n# 这里是估值网络和策略网络的不同，策略网络本身就具有随机性，所以不需要引入\n# 额外的参数e和pre_train_steps来控制随机探索的强度。\n# 策略网络在训练的过程中，本身就是由随机性大，到慢慢的收敛到好的Action\n# 所以可以直接得到好的探索的训练样本。估值网络没有这样好的性质，它连\n# 随机性都没有，就需要人为的制造，满足从完全随机探索，到在好的Action的\n# 基础上具有一定的随机性进行探索。\n```\n\n**这是策略网络和估值网络的共通之处，其实这也最上面那个注释\"by greedily (with e chance of random action) from the Q-network\"的意思。**\n\n**<font color=green>“贪心”两个字完美的诠释了强化学习，无论是策略网络还是估值网络，在探索阶段，在生成数据集上的特点。</font>**\n\n在策略网络那一节，我做的那个试验，和模型无关生成数据集。其实就是不贪心了，不贪心不行。\n\n```python\nif total_steps > pre_train_steps:\n    if e > endE:\n        e -= stepDrop\n# 完全随机了之后，开始慢慢减小随机性。\n# 模型约不可靠的时候，探索性和随机性越强。后来模型慢慢变得可靠就减弱随机性。\n# 因为模型越来越可靠的时候，随机性大就会得到很多远远低于当前模型性能的试验\n# 这些试验都是早就被pass了的，学不到什么东西，损坏模型的探索。\n# endE=0.1 说明无论训练的多好，模型都保持了随机性，保持了探索性\n#　人永远要有好奇心，永远要觉得自己的知识还可能不是最好的\n```\n\n\n\n下面的代码是将在数据集弄好的情况下，如何训练模型的。\n\n```python \nif total_steps % (update_freq) == 0:\n    trainBatch = myBuffer.sample(batch_size) #Get a random batch of experiences.\n    #Below we perform the Double-DQN update to the target Q-values\n    # 主网络预测了下一刻需要采取的Action，trainBatch[:,3]是当前的下一刻的环境\n    # 回顾公式，Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)\n    # 这里主函数预测的Action就是t+1时刻（下一时刻）获益值最大的Action\n    Q1 = sess.run(mainQN.predict,feed_dict={mainQN.scalarInput:np.vstack(trainBatch[:,3])})\n    # target网络预测了下一时刻的reward\n    Q2 = sess.run(targetQN.Qout,feed_dict={targetQN.scalarInput:np.vstack(trainBatch[:,3])})\n    end_multiplier = -(trainBatch[:,4] - 1)\n    # 用主网络预测出的Action以及target网络预测出的所有行为的reward\n    # 选择了最大的reward,也就是公式中的 Max Q(s_t+1, a)\n    doubleQ = Q2[range(batch_size),Q1]\n    # 这里得到的就是公式Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)\n    # 的右边，当前reward加上乘以衰减系数之后的，下一步最大reward\n    targetQ = trainBatch[:,2] + (y*doubleQ * end_multiplier)\n    #Update the network with our target values.\n    # 公式右边得到了之后，在把真正的当前状态输入进去，得到左边\n    # 左边以右边作为标签进行学习。更新主网络的参数\n    _ = sess.run(mainQN.updateModel, \\\n                 feed_dict={mainQN.scalarInput:np.vstack(trainBatch[:,0]),mainQN.targetQ:targetQ, mainQN.actions:trainBatch[:,1]})\n    # 更新target网络的参数。\n    updateTarget(targetOps,sess) #Update the target network toward the primary network.\n```\n\n\n\ntarget网络参数的更新方式代码\n\n```python \ndef updateTargetGraph(tfVars,tau):\n    total_vars = len(tfVars)\n    op_holder = [] \n    # 主网络是和target网络一样的，前一半参数正好是主网络的参数\n    for idx,var in enumerate(tfVars[0:total_vars//2]):\n        # idx+total_vars对应的时候后一半的参数也就是target网络的参数\n        # 这里相当于是target参数 = 主网络参数 * tau + （1- tau）*target参数\n        # 也就是说target网络在以一定的速度向主网络靠近\n        # 结合前面的代码，主网络才是真正学习的网络，target网络的作用仅仅是得到等式\n        # 右边的值，即标签，即使是等式右边，也不是target网络完全决定的\n        # target网络得到了所有Action的reward，最大的Action是主网络选择的\n        # 为什么要这么做，target网络也是在模仿主网络，只用主网络也能得到等式的右边\n        # 理论上其实右边也应该是主网络决定，现在搞了个主网络的模仿者target网络\n        # 是出于优化的考虑。我们后面叙述。\n        op_holder.append(tfVars[idx+total_vars//2].assign\\\\\n                         ((var.value()*tau) \\\\\n                      + ((1-tau)*tfVars[idx+total_vars//2].value())))\n        return op_holder\n\n    def updateTarget(op_holder,sess):\n        for op in op_holder:\n            sess.run(op)\n\n```\n\n现在其实我们把关键的代码都看了，在这段代码实现中，引入了一些state of the art的trick，下面我们结合看过的代码在提一遍。\n\n1. 引入卷积层，这段代码比较简单，我们没有看。环境状态是用图片的形式给的，用CNN提取特征是比较自然的。\n2. Experience replay。估值网络不像策略网络一样得到试验之后，用一次就扔掉再去制作新的试验（数据集）来训练。它把每次试验都放在一个试验池里面。试验池长度为N，如果超过了N，那就把最老的试验样本扔掉。每次 训练的时候从试验池里面随机选择batchsize个样本进行训练，保持了对样本的利用率，同时其实也增加了模型的稳定性，因为数据集是相对稳定的（相比于N=1而言，每次训练了就扔掉，进来的都是新的，不那么稳定）。\n3. 使用target网络来辅助训练。**之所以要用target网络来制造训练目标，用主网络来实际训练，是为了让Q-Learing训练的目标保持平稳。**强化学习不像普通的监督学习，它的目标是变化的，**因为学习目标的一部分就是模型本身输出的。**每次更新模型参数都会导致学习目标发生变化，如果更新频繁，幅度很大，我们的训练过程就会变得非常不稳定并且失控。**DQN的训练会陷入目标Q与预测Q的反馈循环中，震荡发散。**所以用target网络来制造目标，target网络和主网络又不是矛盾的，因为target网络会逼近主网络，它是主网络的模仿者，所以它提供的目标Q也是有权威的。\n4. Double DQN。这个trick源于target网络选的最大Action不准。模仿的不够好，现在就让主网络来帮它选。也就是上面代码中我们看过了主网络输出action，选择target网络输出的reward，得到公式的右边。\n5. Dueling DQN。上代码\n\n```python \nself.AW = tf.Variable(xavier_init([h_size//2,env.actions]))\nself.VW = tf.Variable(xavier_init([h_size//2,1]))\nself.Advantage = tf.matmul(self.streamA,self.AW)\nself.Value = tf.matmul(self.streamV,self.VW)\n\n#Then combine them together to get our final Q-values.\n# 看这里Qout是网络最终预测的所有Action的reward。它由两部分组成Value和Advantage\n# 由最上面两行可以看出Value是一维的，是实数，advantage是#action维度的向量\n# 所以，Dueling DQN就是将reward裁成了两部分，一部分是环境状态本身具有的价值Value\n# 另一部分就是Action本身具有的价值，相加起来就是在这个环境下Action具有的价值。\n# 其实我感觉这些解释都是人为的，具体是不是这样谁也不知道，可能只是这样优化的好。\n#　因为即使不分为两部分，网络输出Ｑout的时候，输入也是环境状态，肯定都会把环境考虑\n# 进去才有Action的价值。然而直接输出这个价值，发现优化的不好，分为两部分之后，发现\n# 优化的好了。其实谁也不知道其中到底是什么原因起作用。\nself.Qout = self.Value + tf.subtract(self.Advantage,tf.reduce_mean(self.Advantage,axis=1,keep_dims=True))\n```\n\n\n\n# 回顾\n\n强化学习的本质是连续决策。强化学习算法的关键是标签制作，数据集制作。\n\n连续决策问题是没有确定的标签的，它通过探索试验得到数据集和标签，为没有提供标签的问题，做了标签，让问题可以解决。\n\n深度学习无法优化离散的不可导的参数，强化学习也可以通过在离散的地方做数据集做标签，把它转换为可导的，可用sgd优化的问题。\n\n做标签和数据集的关键是随机性以及贪心，贪心让它立足于以往的知识，随机让它不刚愎自用，保持谦卑，给新的可能保留空间。\n\n\n\n无论是策略网络还是估值网络，在数据集的制作上都是一样的，随机性和贪心。估值网络的数据集制作，可以看出强化学习探索的本质（由于估值网络本身没有随机性，它在制作数据集的时候，显示的暴露了，探索和贪心的本质。策略网络这方面还不太好看出来，因为它是隐式的利用探索和贪心）。\n\n\n\n策略网络，增大所有行为的概率，但是对于reward大 的行为增大的权重大。这个思路在我得感觉上更加符合强化两个字。强化好的行为嘛。\n\n估值网络的本质是公式Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，有点递归的感觉。\n\n策略网络和估值网络数据集也有一点不同，策略网络的数据集是纵向的，一串行为一起的。而估值网络的数据集是单个单个的。\n\n由下面代码可以看出，策略网络中，每一窜试验就会训练一次，只是网络参数更新会积累了好几次试验之后才更新。策略网络关心从开始到结束一系列行为。而估值网络只关心当前和下一状态。\n\n```python \nif done:\n    episode_number += 1\n    epx = np.vstack(xs)\n    epy = np.vstack(ys)\n    epr = np.vstack(drs)\n    tfp = tfps\n    xs,hs,dlogps,drs,ys,tfps = [],[],[],[],[],[]\n\n    discounted_epr = discount_rewards(epr)\n    discounted_epr -= np.mean(discounted_epr)\n    discounted_epr //= np.std(discounted_epr)\n\n    tGrad = sess.run(newGrads,feed_dict={observations: epx, input_y: epy, advantages: discounted_epr})\n    for ix,grad in enumerate(tGrad):\n        gradBuffer[ix] += grad\n\n        if episode_number % batch_size == 0:\n            sess.run(updateGrads,feed_dict={W1Grad: gradBuffer[0],W1_1Grad:gradBuffer[1],W2Grad:gradBuffer[2]})\n```\n\n估值网络人为的控制随机强度，也是一个值得考虑的问题。\n\n\n\n","slug":"First-Step-to-RL","published":1,"updated":"2021-12-10T13:04:43.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckx0fk1vp000gxoul8sy9efld","content":"<p>强化学习的入门介绍</p>\n<p>什么是强化学习</p>\n<p>深度强化学习算法：策略网络(Policy Network)和估值网络(Value Network)</p>\n<span id=\"more\"></span>\n\n<h1 id=\"什么是强化学习，关于强化学习的几点疑问\"><span class=\"post-title-index\">1. </span><a href=\"#什么是强化学习，关于强化学习的几点疑问\" class=\"headerlink\" title=\"什么是强化学习，关于强化学习的几点疑问\"></a>什么是强化学习，关于强化学习的几点疑问</h1><p><font color=\"green\" size=\"3\">强化学习三要素：环境状态，行动，奖励</font></p>\n<p><font color=\"green\" size=\"3\">目标：尽量多的获得奖励</font></p>\n<p><font color=\"green\" size=\"3\">本质：连续决策</font></p>\n<p>基本的强化学习模型包括：</p>\n<ul>\n<li>环境状态的集合S</li>\n<li>动作的集合A</li>\n<li>状态之间的转换规则（是环境的一部分）</li>\n<li>规定转换后“即时奖励”的规则（是环境的一部分）</li>\n<li>描述主体（智能体）能够观察到什么的规则（是环境的一部分）</li>\n<li>能够做出决策/动作的主体（智能体）</li>\n</ul>\n<h2 id=\"区别于深度学习，强化学习的本质特点是什么？\"><span class=\"post-title-index\">1.1. </span><a href=\"#区别于深度学习，强化学习的本质特点是什么？\" class=\"headerlink\" title=\"区别于深度学习，强化学习的本质特点是什么？\"></a>区别于深度学习，强化学习的本质特点是什么？</h2><p><strong>两个定义</strong></p>\n<p>1，强化学习是机器学习的一个重要分支，主要用来解决连续决策问题。</p>\n<p>2，强化学习又称 再励学习，评价学习或增强学习，是机器学习的范式和方法论之一，用于描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。</p>\n<p>强化学习的本质是<font color=\"red\"> 描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。</font>它本质是这样一种场景，在这种场景中它为了达到某种目的，做出连续的决策。这样符合这种场景，那就是强化学习。</p>\n<p>强化学习和深度学习这两个名词的维度是不一样的。深度学习描述的是算法本身的特点，深度够不够，是不是连接主义的模型。深度学习可以用来做无监督，也可以用来做半监督，也可以用来做弱监督，甚至可以用来作为强化学习算法的一部分。深度学习这个名词，不管应用场景只管模型本身是不是满足深度学习的特点。</p>\n<p>而强化学习描述的是应用场景的特点，只要能提供智能体决策的算法，管它是什么模型，什么结构，那就是强化学习的算法。从这个角度上讲，我现在认为强化学习和监督学习，无监督学习，弱监督学习，是并列的，是对应用场景的描述。和深度学习不是同一维度的。</p>\n<p><font color=\"red\">强化学习的本质在于目标给定的形式，不像无监督学习那样完全没有学习目标，也不像监督学习那样有非常明确的目标（label），强化学习的目标一般是变化的，不明确的，甚至可能不存在绝对正确的目标。，强化学习的问题都可以抽象成，环境状态，行动和奖励。应该说只要能抽象为这三个要素，目标是获得最大奖励的模型，就是强化学习的模型。</font></p>\n<p>强化学习的最大的特点是“试错”，是尝试各种可能，而强化结果好的可能。（策略网络的特点，估值网络的特点是修正和预测获益）</p>\n<p>由于强化学习是一种决策学习，这个问题的特点就是离散型。但是离散并不就是强化学习（连续的决策才是，目标的模糊和不确定性是决策问题的特点）。深度学习本质是函数的拟合，所以连续可微是它的特点。并不能说连续可微的问题就是深度学习，离散的问题就是强化学习。 </p>\n<h2 id=\"深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\"><span class=\"post-title-index\">1.2. </span><a href=\"#深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\" class=\"headerlink\" title=\"深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\"></a>深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？</h2><p>这个问题要了解下一节，具体的强化学习方法。</p>\n<h2 id=\"强化学习与弱监督学习？\"><span class=\"post-title-index\">1.3. </span><a href=\"#强化学习与弱监督学习？\" class=\"headerlink\" title=\"强化学习与弱监督学习？\"></a>强化学习与弱监督学习？</h2><p>弱监督是属于有监督学习，只是它学习的目标不是被给予的标签，而是比被给予标签更强的标签（强弱是指标签做含有的信息量），也就是说弱监督是根据少量信息的标签，推测出更多的信息。</p>\n<p>强化学习的本质是连续决策。连续决策的特点是目标的模糊和不确定性。</p>\n<p>所以，虽然弱监督和强化学习都没有给出最终准确的目标，但是他们任然很不同的</p>\n<h2 id=\"深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\"><span class=\"post-title-index\">1.4. </span><a href=\"#深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\" class=\"headerlink\" title=\"深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\"></a>深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法</h2><p>深度学习大部分我们用作有监督的学习算法。其实说深度学习是死的，不如说有监督学习是死的。</p>\n<p>有监督学习其实是完全的复刻标签里面含有的知识，它的本质就是一个函数拟合的问题，它无法摆脱对绝对的标签的依赖，无法超越标签。</p>\n<p>而强化学习，正由于它的目标是模糊和不确定的。使得算法在设计上必须具有随机性和探索性，它能够探索出人类从来没有到过的领域。就像在围棋上，下出人类完全无法理解的棋，人从来没有想过的一些下法。这就是强化学习算法探索出来的知识。所以我觉得它是活着的，拥有智能的算法。</p>\n<p><font color=\"green\">从感性的层面，强化学习算法很接近人脑的行为：感知环境，探索环境，强化有益行为</font></p>\n<h2 id=\"关于深度学习，强化学习，连续可导性和离散不可导性的讨论\"><span class=\"post-title-index\">1.5. </span><a href=\"#关于深度学习，强化学习，连续可导性和离散不可导性的讨论\" class=\"headerlink\" title=\"关于深度学习，强化学习，连续可导性和离散不可导性的讨论\"></a>关于深度学习，强化学习，连续可导性和离散不可导性的讨论</h2><ol>\n<li><p>从函数的角度，深度学习和强化学习都需要学习一个函数映射。深度学习是从输入到target的映射。强化学习是学从环境状态到Action的映射。这两个映射可以看成性质一样的，因为深度学习可以作为强化学习的智能体。所以从函数的角度，他们没有连续和离散的区别。（PS. 深度学习模型和强化学习的智能体都是连续可导的函数。target和Action都可以是离散的或者连续的。）</p>\n</li>\n<li><p>深度学习作为用梯度下降算法优化的模型，无法优化对loss不可导的参数。如在深度学习中，设计一个分支来决定模型是否应该包含某个模块，这个分支的参数是不可优化的。因为包含和不包含是离散的，对loss不可导。</p>\n<p>不过假设，如果包含与不包含是连续的。也就是说，可以以0.1的权重包含。那么，这些参数是可以优化的。从这点来看，离散就是导致模型参数不可优化的原因。</p>\n</li>\n<li><p>强化学习在离散的情况下解决2中的问题。由此，我得到了一个概念，强化学习解决离散的问题。</p>\n</li>\n<li><p>下面我们来分析一下这个场景。首先，决定一个模块该不该被使用，这个场景是一次Action的场景，不是连续决策的场景。也就是说Action一次，我就能知道最终reward多少了，只有单步的reward。</p>\n<p>限于这个单次决策的场景来看，如果Action相对于reward是连续可导的，那么深度学习就能解决这个问题。如果Action相对于reward是离散的，那么仅仅深度学习无法解决这个问题，要靠强化学习。</p>\n<p><font color=\"green\">这里单次Action就知道reward，实际上这个问题就退化为了有监督学习，因为这个单步的reward就可以看成我的标签了。所以深度学习解决这个问题是很自然的。</font></p>\n</li>\n<li><p>多次决策的问题，无论是连续的还是离散的都只能用强化学习的方法。因为多次决策，这个问题就不可以退化为监督学习的问题了。它是一个真正的强化学习的问题。</p>\n</li>\n</ol>\n<p>综上所诉，强化学习解决深度学习解决不了的离散问题，那只是在单次决策的时候，这个问题退化为了有监督学习。强化学习的方法，恰好可以提供离散变量的学习。</p>\n<p>强化学习方法解决深度学习中的离散问题，仅仅是强化学习附带的一个小福利。</p>\n<p><strong><font color=\"green\">因为它能把经验转化为可导的目标，就拿策略网络来说，从梯度的角度，它只管增加当前随机Action的概率，而加入advatage之后，自动就优化除了想要的大reward的行为。</font></strong></p>\n<h2 id=\"深度学习优化和强化学习优化的感性理解\"><span class=\"post-title-index\">1.6. </span><a href=\"#深度学习优化和强化学习优化的感性理解\" class=\"headerlink\" title=\"深度学习优化和强化学习优化的感性理解\"></a>深度学习优化和强化学习优化的感性理解</h2><p>前面说了深度学习优化可导的参数，强化学习可以优化不可导的参数。这里说一下对深度学习优化方法和强化学习优化方法的感性理解。</p>\n<p>还是说前面包不会包含某模块的例子，由于连续可导，对于每一个参数值，深度学习模型其实都同时参与了两种Action（包含和不包含）。score = 0.1 包含，其实其中包含了含有的成分，也包含了不含有的成分。所以我们可以连续的变动score，看看包含多好，还是不好含多好。这其实就是梯度下降算法的方式。得益于每一个参数，其实我都对包含和不包含的情况都有了解，我当然知道哪个更好，就往那边移动（优化）。</p>\n<p>然而，对于离散的情况，要么只能包含，要么只能不包含。当选择包含的时候，模型对不包含的情况完全是无知的。可能更好，也可能差。当不包含的时候，也是一样的。无论哪种情况，我都没有办法优化，两种情况是完全隔离开的，信息不沟通的，是离散的。所以梯度下降算法无法优化它。</p>\n<p>强化学习用随机探索的方法让两者信息又沟通起来。包含一下试一下，然后，不包含也试一下。尝试的结果是哪种reward多，就增大哪种的概率。</p>\n<p><strong><font color=\"green\">所以，无论哪种优化方法，信息的沟通都是必要的。要对所有的action都了解，才能知道选择哪种action。 只是深度学习是连续的，它的每一种参数，都包含了所有Action的信息（reward），每一种Action都参与了，所以它能直接连续的梯度下降的优化，不需要随机探索了。而对于离散的，每种action只能知道自己的reward，对其他Action一无所知的时候，梯度的优化是不行的。必须要探索各种Action，还是要知道了每一种Action的情况(reward)之后，才能优化。这是方法论。</font></strong></p>\n<p>更进一步，离散的地方，相对于reward一定是不可导的，所以深度学习不行。而强化学习，更准确的说是策略网络，相当于给离散的地方加了标签，这样它就在离散的地方有监督了，它就可以根据增加的标签优化。而标签的设计就是根据探索的结果，增大reward大的Action，reward大的Action就是它的标签，而且这个标签是动态的，是对抗得出的。</p>\n<p>强化学习方法算出的梯度是策略梯度。</p>\n<p><strong><font color=\"green\">强化学习： 不知道选哪边了； 试试呗；按试出来reward大的Action优化它。</font></strong></p>\n<p><strong><font color=\"green\">强化学习：它离散，对于reward不可导；不直接用reward优化它，给它加个标签，把试出来reward大的Action，作为标签去优化</font></strong></p>\n<p>在不可导的地方加标签。</p>\n<p><strong><font color=\"green\">由此，强化学习算法的本质是制作标签，无论是连续决策，标签不确定的情况，还是它能解决离散问题的情况，它都是用制作标签的方法解决的。</font></strong></p>\n<h1 id=\"策略网络-Policy-Network-和估值网络-Value-Network\"><span class=\"post-title-index\">2. </span><a href=\"#策略网络-Policy-Network-和估值网络-Value-Network\" class=\"headerlink\" title=\"策略网络(Policy Network)和估值网络(Value Network)\"></a>策略网络(Policy Network)和估值网络(Value Network)</h1><p>AlphaGo 使用了快速走子，策略网络，估值网络和蒙特卡洛搜索树等技术。</p>\n<p>强化学习算法的一个关键是<font color=\"green\">随机性和探索性</font>，我们需要让算法通过试验样本自己学习什么才是某个环境状态下比较好的Action，而不是像有监督学习一样，告诉模型什么是好的Action，因为我们也不知道什么是好的Action.</p>\n<p>深度强化学习模型的本质是神经网络，神经网络是工具，根据问题转化以及建模的不同，主要分为策略网络和估值网络。</p>\n<p>强化学习中最重要的两类方法<strong>Policy-based,Value-based</strong>。第一种直接预测在某个环境下应该采取的行动（直接输出改采取Action的概率）。第二种预测在某个环境下所有行动的期望价值，然后通过选择q值最高的行动执行策略。</p>\n<p>他们都能完成决策，但由于建模的不同，估值网络包含有更多的信息，它不仅能提供决策，还预测了决策带来的收益。</p>\n<p><font color=\"red\">策略网络是隐式的学习了某一Action所带来的全部获益（当前获益+后续获益），而估值网络直接显示的学习Action所带来的全部获益。</font>强化学习算法做出最佳抉择只需要知道哪个Action全部获益最大，策略网络就是这样做的，估值网络不仅学习了哪个Action全部获益最大，还把每个Action的全部获益给计算出来了。</p>\n<p><font color=\"green\">相对来说，策略网络的性能会比估值网络好一些。</font></p>\n<p><font color=\"green\">Value Based方法适合仅有少量Action的环境，而Policy Based方法更通用，适合Action种类非常多，或者具有连续取值的Action的环境。结合了深度学习之后，Policy Based方法就变成了策略网络，Value Based方法就变成了估值网络。</font></p>\n<h2 id=\"策略网络-Policy-Network\"><span class=\"post-title-index\">2.1. </span><a href=\"#策略网络-Policy-Network\" class=\"headerlink\" title=\"策略网络(Policy Network)\"></a>策略网络(Policy Network)</h2><p>直接看一个例子，学习的目标是，左右用力使得木棍不倒地，<a href=\"https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py\">Policy_Network.py</a></p>\n<p>关键代码</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = tf.matmul(layer1,W2)</span><br><span class=\"line\">probability = tf.nn.sigmoid(score)<span class=\"comment\">#网络输出采取Action 1的概率。</span></span><br><span class=\"line\">input_y = tf.placeholder(tf.float32,[<span class=\"literal\">None</span>,<span class=\"number\">1</span>], \\\\</span><br><span class=\"line\">                         name=<span class=\"string\">&quot;input_y&quot;</span>)<span class=\"comment\"># 输入采取过的行为，这个行为是随机生成的。</span></span><br><span class=\"line\">advantages = tf.placeholder(tf.float32,name=<span class=\"string\">&quot;reward_signal&quot;</span>) </span><br><span class=\"line\"><span class=\"comment\"># 输入获益</span></span><br><span class=\"line\">loglik = tf.log(input_y*(input_y - probability) + \\\\</span><br><span class=\"line\">                (<span class=\"number\">1</span> - input_y)*(input_y + probability)) </span><br><span class=\"line\"><span class=\"comment\"># 损失函数，如果行为是1，则增大</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#概率，如果行为是 0，则减小概率（相当于也是增加0的概率），也就是说这个损</span></span><br><span class=\"line\"><span class=\"comment\">#失函数无论当前行为是什么都会增大当前行为的概率。</span></span><br><span class=\"line\">loss = -tf.reduce_mean(loglik * advantages) <span class=\"comment\"># 这行代码很关键，</span></span><br><span class=\"line\"><span class=\"comment\">#相当于给损失函数成了一个权重advantages，得到最终的损失函数。</span></span><br><span class=\"line\"><span class=\"comment\">#advantages是当前试验的全部获益。如果全部获益大，将以更大的权重，增加 </span></span><br><span class=\"line\"><span class=\"comment\">#当前行为的概率。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#所以，策略网络其实也是一个对抗学习的过程，增加所有采取过行为的概率，只是</span></span><br><span class=\"line\"><span class=\"comment\">#获益多的行为以更大的权重增加。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 一个试验： 由初始状态开始，随机采取一连串的行为</span></span><br><span class=\"line\"><span class=\"comment\">#（Policy_Network.py 中是根据当前模型输出的概率,来生成随机的行为，但</span></span><br><span class=\"line\"><span class=\"comment\">#是我感觉直接用0.5的概率随机生成一连串的0和1的行为也是可以的，下面将实</span></span><br><span class=\"line\"><span class=\"comment\">#验一下），直到任务结束。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 由于每个试验，都可以一直行为到任务结束，所以每个action，我们都可以得</span></span><br><span class=\"line\"><span class=\"comment\">#到它在该试验中的全部获益（当前获益 + 之后所有行为的获益）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 随机生成了n个试验，其中又各种各样的决策（随机探索），全部获益大的</span></span><br><span class=\"line\"><span class=\"comment\">#action，它的advantages也大，那么它的概率就增大的多，它被强化的厉害。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 试验生成的过程，实际上就是数据集构建的过程。策略网络的数据集是由环境</span></span><br><span class=\"line\"><span class=\"comment\">#和一系列随机的行为构成的。它提供了环境在各种行为下的反应（获益）。模型</span></span><br><span class=\"line\"><span class=\"comment\">#学习为环境带来高获益的行为的规律。</span></span><br></pre></td></tr></table></figure>\n\n<p>由上面的代码可知，从策略网络的角度看强化学习的话，强化学习的关键其实是对数据集的构建—如何构建数据集。</p>\n<p>在构建数据集的时候，随机探索肯定是必要的。随机探索的结果会得到一系列好的行为，也会得到一系列不好的行为。如何强化好的行为就是算法设计的时候需要注意的。</p>\n<p>上面的代码在探索阶段借用了当前的模型，即根据当前模型输出的概率随机生成行为，从而形成数据集。如果完全的随机（一直使用0.5的概率随机的生成Action）会什么样呢？</p>\n<h3 id=\"数据集是否可以和模型无关（不随着模型变化）？\"><span class=\"post-title-index\">2.1.1. </span><a href=\"#数据集是否可以和模型无关（不随着模型变化）？\" class=\"headerlink\" title=\"数据集是否可以和模型无关（不随着模型变化）？\"></a>数据集是否可以和模型无关（不随着模型变化）？</h3><p>关键修改代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基于当前模型，根据当前的状态x，生成Action 1的概率</span></span><br><span class=\"line\">tfprob = sess.run(probability,feed_dict=&#123;observations: x&#125;)</span><br><span class=\"line\"><span class=\"comment\"># 基于预测概率，随机生成行为，并试探环境。生成数据集。</span></span><br><span class=\"line\">action = <span class=\"number\">1</span> <span class=\"keyword\">if</span> np.random.uniform() &lt; tfprob <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>修改后</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注释掉这句，并不需要根据当前模型生成概率</span></span><br><span class=\"line\"><span class=\"comment\"># tfprob = sess.run(probability,feed_dict=&#123;observations: x&#125;)</span></span><br><span class=\"line\"><span class=\"comment\"># 直接设置概率为0.5，随机完全随机探索生成数据集。</span></span><br><span class=\"line\">tfprob = <span class=\"number\">0.5</span></span><br><span class=\"line\">action = <span class=\"number\">1</span> <span class=\"keyword\">if</span> np.random.uniform() &lt; tfprob <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>结果：修改后，模型无法收敛。</p>\n<p>完全随机很小的概率能探索出很好的试验，这些好的行为也很难持续的得到强化。</p>\n<p>所以，强化学习也有一种效果叠加的感觉。在完全随机的情况下 ，探索出相对好的action，再在这个相对好的action的基础上，在探索探索出更好的action。</p>\n<p>如果数据集不依赖模型，就是一直在完全随机的基础上探索。这样很难收敛。</p>\n<p>也可以这样看，完全随机的话，最多能学到前几步的策略（因为完全随机就走不了几步，探索的经验就只有那几步）。依赖于模型，探索的行为更有价值，因为是依赖于学到过的知识的，一方面确认了，按学到的知识走，确实获益多，一方面又在学到的知识的基础上，做了一些随机，探索更好的知识。</p>\n<h2 id=\"估值网络-Value-Network，Q-learning\"><span class=\"post-title-index\">2.2. </span><a href=\"#估值网络-Value-Network，Q-learning\" class=\"headerlink\" title=\"估值网络(Value Network，Q-learning)\"></a>估值网络(Value Network，Q-learning)</h2><p>Q-Learing用神经网络实现，得到的模型就是估值网络。</p>\n<p>也看一个例子，<a href=\"https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py\">Value_Network.py</a></p>\n<p>学习每个Action所对应的reward的期望。</p>\n<p>我们先看看数据集的结构</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Save the experience to our episode buffer.</span></span><br><span class=\"line\">episodeBuffer.add(np.reshape(np.array([s,a,r,s1,d]),[<span class=\"number\">1</span>,<span class=\"number\">5</span>]))</span><br><span class=\"line\"><span class=\"comment\"># 其中s是当前时刻的环境状态，a是当前随机采取的Action，r是这个Action的当前reward</span></span><br><span class=\"line\"><span class=\"comment\"># s1是采取Action之后的下一状态，d是布尔型表示是否任务结束。  </span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>现在目标是学习Q(s<sub>t</sub>, a<sub>t</sub>)，也就是当前环境状态，采取行为a的全部reward的期望。</p>\n</li>\n<li><p>现在假设我们有模型Q<sub>desird</sub>，可以预测全部reward了，那么这个模型应该满足条件，Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，这有点递归的感觉了。</p>\n</li>\n<li><p>现在我们能不能根据这个公式 ， 来优化出Q<sub>desired</sub>。肯定是能的。对于探索过的所有试验，公式都满足的话，此时的模型就可以看成我们想要的模型了。我感觉这就是估值网络方法的核心。</p>\n</li>\n</ol>\n<p>直接看关键代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Choose an action by greedily (with e chance of random action)</span></span><br><span class=\"line\"><span class=\"comment\"># from the Q-network</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> np.random.rand(<span class=\"number\">1</span>) &lt; e <span class=\"keyword\">or</span> total_steps &lt; pre_train_steps:</span><br><span class=\"line\">    a = np.random.randint(<span class=\"number\">0</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    a = sess.run(mainQN.predict,feed_dict=&#123;mainQN.scalarInput:[s]&#125;)[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># 这段代码其实是探索的代码，当最开始的时候是完全随机探索（total_steps &lt; pre_train_steps的时候）</span></span><br><span class=\"line\"><span class=\"comment\"># 当total_steps &gt;= pre_train_steps之后呢，就不是完全随机探索了。</span></span><br><span class=\"line\"><span class=\"comment\"># 有e的概率是随机探索的，（1-e）的概率是由训练好的模型决定之后的Action。 </span></span><br><span class=\"line\"><span class=\"comment\"># 这里是估值网络和策略网络的不同，策略网络本身就具有随机性，所以不需要引入</span></span><br><span class=\"line\"><span class=\"comment\"># 额外的参数e和pre_train_steps来控制随机探索的强度。</span></span><br><span class=\"line\"><span class=\"comment\"># 策略网络在训练的过程中，本身就是由随机性大，到慢慢的收敛到好的Action</span></span><br><span class=\"line\"><span class=\"comment\"># 所以可以直接得到好的探索的训练样本。估值网络没有这样好的性质，它连</span></span><br><span class=\"line\"><span class=\"comment\"># 随机性都没有，就需要人为的制造，满足从完全随机探索，到在好的Action的</span></span><br><span class=\"line\"><span class=\"comment\"># 基础上具有一定的随机性进行探索。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>这是策略网络和估值网络的共通之处，其实这也最上面那个注释”by greedily (with e chance of random action) from the Q-network”的意思。</strong></p>\n<p><strong><font color=\"green\">“贪心”两个字完美的诠释了强化学习，无论是策略网络还是估值网络，在探索阶段，在生成数据集上的特点。</font></strong></p>\n<p>在策略网络那一节，我做的那个试验，和模型无关生成数据集。其实就是不贪心了，不贪心不行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> total_steps &gt; pre_train_steps:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> e &gt; endE:</span><br><span class=\"line\">        e -= stepDrop</span><br><span class=\"line\"><span class=\"comment\"># 完全随机了之后，开始慢慢减小随机性。</span></span><br><span class=\"line\"><span class=\"comment\"># 模型约不可靠的时候，探索性和随机性越强。后来模型慢慢变得可靠就减弱随机性。</span></span><br><span class=\"line\"><span class=\"comment\"># 因为模型越来越可靠的时候，随机性大就会得到很多远远低于当前模型性能的试验</span></span><br><span class=\"line\"><span class=\"comment\"># 这些试验都是早就被pass了的，学不到什么东西，损坏模型的探索。</span></span><br><span class=\"line\"><span class=\"comment\"># endE=0.1 说明无论训练的多好，模型都保持了随机性，保持了探索性</span></span><br><span class=\"line\"><span class=\"comment\">#　人永远要有好奇心，永远要觉得自己的知识还可能不是最好的</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>下面的代码是将在数据集弄好的情况下，如何训练模型的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> total_steps % (update_freq) == <span class=\"number\">0</span>:</span><br><span class=\"line\">    trainBatch = myBuffer.sample(batch_size) <span class=\"comment\">#Get a random batch of experiences.</span></span><br><span class=\"line\">    <span class=\"comment\">#Below we perform the Double-DQN update to the target Q-values</span></span><br><span class=\"line\">    <span class=\"comment\"># 主网络预测了下一刻需要采取的Action，trainBatch[:,3]是当前的下一刻的环境</span></span><br><span class=\"line\">    <span class=\"comment\"># 回顾公式，Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里主函数预测的Action就是t+1时刻（下一时刻）获益值最大的Action</span></span><br><span class=\"line\">    Q1 = sess.run(mainQN.predict,feed_dict=&#123;mainQN.scalarInput:np.vstack(trainBatch[:,<span class=\"number\">3</span>])&#125;)</span><br><span class=\"line\">    <span class=\"comment\"># target网络预测了下一时刻的reward</span></span><br><span class=\"line\">    Q2 = sess.run(targetQN.Qout,feed_dict=&#123;targetQN.scalarInput:np.vstack(trainBatch[:,<span class=\"number\">3</span>])&#125;)</span><br><span class=\"line\">    end_multiplier = -(trainBatch[:,<span class=\"number\">4</span>] - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 用主网络预测出的Action以及target网络预测出的所有行为的reward</span></span><br><span class=\"line\">    <span class=\"comment\"># 选择了最大的reward,也就是公式中的 Max Q(s_t+1, a)</span></span><br><span class=\"line\">    doubleQ = Q2[<span class=\"built_in\">range</span>(batch_size),Q1]</span><br><span class=\"line\">    <span class=\"comment\"># 这里得到的就是公式Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)</span></span><br><span class=\"line\">    <span class=\"comment\"># 的右边，当前reward加上乘以衰减系数之后的，下一步最大reward</span></span><br><span class=\"line\">    targetQ = trainBatch[:,<span class=\"number\">2</span>] + (y*doubleQ * end_multiplier)</span><br><span class=\"line\">    <span class=\"comment\">#Update the network with our target values.</span></span><br><span class=\"line\">    <span class=\"comment\"># 公式右边得到了之后，在把真正的当前状态输入进去，得到左边</span></span><br><span class=\"line\">    <span class=\"comment\"># 左边以右边作为标签进行学习。更新主网络的参数</span></span><br><span class=\"line\">    _ = sess.run(mainQN.updateModel, \\</span><br><span class=\"line\">                 feed_dict=&#123;mainQN.scalarInput:np.vstack(trainBatch[:,<span class=\"number\">0</span>]),mainQN.targetQ:targetQ, mainQN.actions:trainBatch[:,<span class=\"number\">1</span>]&#125;)</span><br><span class=\"line\">    <span class=\"comment\"># 更新target网络的参数。</span></span><br><span class=\"line\">    updateTarget(targetOps,sess) <span class=\"comment\">#Update the target network toward the primary network.</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>target网络参数的更新方式代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">updateTargetGraph</span>(<span class=\"params\">tfVars,tau</span>):</span></span><br><span class=\"line\">    total_vars = <span class=\"built_in\">len</span>(tfVars)</span><br><span class=\"line\">    op_holder = [] </span><br><span class=\"line\">    <span class=\"comment\"># 主网络是和target网络一样的，前一半参数正好是主网络的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx,var <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(tfVars[<span class=\"number\">0</span>:total_vars//<span class=\"number\">2</span>]):</span><br><span class=\"line\">        <span class=\"comment\"># idx+total_vars对应的时候后一半的参数也就是target网络的参数</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里相当于是target参数 = 主网络参数 * tau + （1- tau）*target参数</span></span><br><span class=\"line\">        <span class=\"comment\"># 也就是说target网络在以一定的速度向主网络靠近</span></span><br><span class=\"line\">        <span class=\"comment\"># 结合前面的代码，主网络才是真正学习的网络，target网络的作用仅仅是得到等式</span></span><br><span class=\"line\">        <span class=\"comment\"># 右边的值，即标签，即使是等式右边，也不是target网络完全决定的</span></span><br><span class=\"line\">        <span class=\"comment\"># target网络得到了所有Action的reward，最大的Action是主网络选择的</span></span><br><span class=\"line\">        <span class=\"comment\"># 为什么要这么做，target网络也是在模仿主网络，只用主网络也能得到等式的右边</span></span><br><span class=\"line\">        <span class=\"comment\"># 理论上其实右边也应该是主网络决定，现在搞了个主网络的模仿者target网络</span></span><br><span class=\"line\">        <span class=\"comment\"># 是出于优化的考虑。我们后面叙述。</span></span><br><span class=\"line\">        op_holder.append(tfVars[idx+total_vars//<span class=\"number\">2</span>].assign\\\\</span><br><span class=\"line\">                         ((var.value()*tau) \\\\</span><br><span class=\"line\">                      + ((<span class=\"number\">1</span>-tau)*tfVars[idx+total_vars//<span class=\"number\">2</span>].value())))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> op_holder</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">updateTarget</span>(<span class=\"params\">op_holder,sess</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> op <span class=\"keyword\">in</span> op_holder:</span><br><span class=\"line\">            sess.run(op)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在其实我们把关键的代码都看了，在这段代码实现中，引入了一些state of the art的trick，下面我们结合看过的代码在提一遍。</p>\n<ol>\n<li>引入卷积层，这段代码比较简单，我们没有看。环境状态是用图片的形式给的，用CNN提取特征是比较自然的。</li>\n<li>Experience replay。估值网络不像策略网络一样得到试验之后，用一次就扔掉再去制作新的试验（数据集）来训练。它把每次试验都放在一个试验池里面。试验池长度为N，如果超过了N，那就把最老的试验样本扔掉。每次 训练的时候从试验池里面随机选择batchsize个样本进行训练，保持了对样本的利用率，同时其实也增加了模型的稳定性，因为数据集是相对稳定的（相比于N=1而言，每次训练了就扔掉，进来的都是新的，不那么稳定）。</li>\n<li>使用target网络来辅助训练。<strong>之所以要用target网络来制造训练目标，用主网络来实际训练，是为了让Q-Learing训练的目标保持平稳。</strong>强化学习不像普通的监督学习，它的目标是变化的，<strong>因为学习目标的一部分就是模型本身输出的。</strong>每次更新模型参数都会导致学习目标发生变化，如果更新频繁，幅度很大，我们的训练过程就会变得非常不稳定并且失控。<strong>DQN的训练会陷入目标Q与预测Q的反馈循环中，震荡发散。</strong>所以用target网络来制造目标，target网络和主网络又不是矛盾的，因为target网络会逼近主网络，它是主网络的模仿者，所以它提供的目标Q也是有权威的。</li>\n<li>Double DQN。这个trick源于target网络选的最大Action不准。模仿的不够好，现在就让主网络来帮它选。也就是上面代码中我们看过了主网络输出action，选择target网络输出的reward，得到公式的右边。</li>\n<li>Dueling DQN。上代码</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.AW = tf.Variable(xavier_init([h_size//<span class=\"number\">2</span>,env.actions]))</span><br><span class=\"line\">self.VW = tf.Variable(xavier_init([h_size//<span class=\"number\">2</span>,<span class=\"number\">1</span>]))</span><br><span class=\"line\">self.Advantage = tf.matmul(self.streamA,self.AW)</span><br><span class=\"line\">self.Value = tf.matmul(self.streamV,self.VW)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Then combine them together to get our final Q-values.</span></span><br><span class=\"line\"><span class=\"comment\"># 看这里Qout是网络最终预测的所有Action的reward。它由两部分组成Value和Advantage</span></span><br><span class=\"line\"><span class=\"comment\"># 由最上面两行可以看出Value是一维的，是实数，advantage是#action维度的向量</span></span><br><span class=\"line\"><span class=\"comment\"># 所以，Dueling DQN就是将reward裁成了两部分，一部分是环境状态本身具有的价值Value</span></span><br><span class=\"line\"><span class=\"comment\"># 另一部分就是Action本身具有的价值，相加起来就是在这个环境下Action具有的价值。</span></span><br><span class=\"line\"><span class=\"comment\"># 其实我感觉这些解释都是人为的，具体是不是这样谁也不知道，可能只是这样优化的好。</span></span><br><span class=\"line\"><span class=\"comment\">#　因为即使不分为两部分，网络输出Ｑout的时候，输入也是环境状态，肯定都会把环境考虑</span></span><br><span class=\"line\"><span class=\"comment\"># 进去才有Action的价值。然而直接输出这个价值，发现优化的不好，分为两部分之后，发现</span></span><br><span class=\"line\"><span class=\"comment\"># 优化的好了。其实谁也不知道其中到底是什么原因起作用。</span></span><br><span class=\"line\">self.Qout = self.Value + tf.subtract(self.Advantage,tf.reduce_mean(self.Advantage,axis=<span class=\"number\">1</span>,keep_dims=<span class=\"literal\">True</span>))</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"回顾\"><span class=\"post-title-index\">3. </span><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h1><p>强化学习的本质是连续决策。强化学习算法的关键是标签制作，数据集制作。</p>\n<p>连续决策问题是没有确定的标签的，它通过探索试验得到数据集和标签，为没有提供标签的问题，做了标签，让问题可以解决。</p>\n<p>深度学习无法优化离散的不可导的参数，强化学习也可以通过在离散的地方做数据集做标签，把它转换为可导的，可用sgd优化的问题。</p>\n<p>做标签和数据集的关键是随机性以及贪心，贪心让它立足于以往的知识，随机让它不刚愎自用，保持谦卑，给新的可能保留空间。</p>\n<p>无论是策略网络还是估值网络，在数据集的制作上都是一样的，随机性和贪心。估值网络的数据集制作，可以看出强化学习探索的本质（由于估值网络本身没有随机性，它在制作数据集的时候，显示的暴露了，探索和贪心的本质。策略网络这方面还不太好看出来，因为它是隐式的利用探索和贪心）。</p>\n<p>策略网络，增大所有行为的概率，但是对于reward大 的行为增大的权重大。这个思路在我得感觉上更加符合强化两个字。强化好的行为嘛。</p>\n<p>估值网络的本质是公式Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，有点递归的感觉。</p>\n<p>策略网络和估值网络数据集也有一点不同，策略网络的数据集是纵向的，一串行为一起的。而估值网络的数据集是单个单个的。</p>\n<p>由下面代码可以看出，策略网络中，每一窜试验就会训练一次，只是网络参数更新会积累了好几次试验之后才更新。策略网络关心从开始到结束一系列行为。而估值网络只关心当前和下一状态。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> done:</span><br><span class=\"line\">    episode_number += <span class=\"number\">1</span></span><br><span class=\"line\">    epx = np.vstack(xs)</span><br><span class=\"line\">    epy = np.vstack(ys)</span><br><span class=\"line\">    epr = np.vstack(drs)</span><br><span class=\"line\">    tfp = tfps</span><br><span class=\"line\">    xs,hs,dlogps,drs,ys,tfps = [],[],[],[],[],[]</span><br><span class=\"line\"></span><br><span class=\"line\">    discounted_epr = discount_rewards(epr)</span><br><span class=\"line\">    discounted_epr -= np.mean(discounted_epr)</span><br><span class=\"line\">    discounted_epr //= np.std(discounted_epr)</span><br><span class=\"line\"></span><br><span class=\"line\">    tGrad = sess.run(newGrads,feed_dict=&#123;observations: epx, input_y: epy, advantages: discounted_epr&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ix,grad <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(tGrad):</span><br><span class=\"line\">        gradBuffer[ix] += grad</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> episode_number % batch_size == <span class=\"number\">0</span>:</span><br><span class=\"line\">            sess.run(updateGrads,feed_dict=&#123;W1Grad: gradBuffer[<span class=\"number\">0</span>],W1_1Grad:gradBuffer[<span class=\"number\">1</span>],W2Grad:gradBuffer[<span class=\"number\">2</span>]&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>估值网络人为的控制随机强度，也是一个值得考虑的问题。</p>\n","site":{"data":{}},"excerpt":"<p>强化学习的入门介绍</p>\n<p>什么是强化学习</p>\n<p>深度强化学习算法：策略网络(Policy Network)和估值网络(Value Network)</p>","more":"<h1 id=\"什么是强化学习，关于强化学习的几点疑问\"><a href=\"#什么是强化学习，关于强化学习的几点疑问\" class=\"headerlink\" title=\"什么是强化学习，关于强化学习的几点疑问\"></a>什么是强化学习，关于强化学习的几点疑问</h1><p><font color=\"green\" size=\"3\">强化学习三要素：环境状态，行动，奖励</font></p>\n<p><font color=\"green\" size=\"3\">目标：尽量多的获得奖励</font></p>\n<p><font color=\"green\" size=\"3\">本质：连续决策</font></p>\n<p>基本的强化学习模型包括：</p>\n<ul>\n<li>环境状态的集合S</li>\n<li>动作的集合A</li>\n<li>状态之间的转换规则（是环境的一部分）</li>\n<li>规定转换后“即时奖励”的规则（是环境的一部分）</li>\n<li>描述主体（智能体）能够观察到什么的规则（是环境的一部分）</li>\n<li>能够做出决策/动作的主体（智能体）</li>\n</ul>\n<h2 id=\"区别于深度学习，强化学习的本质特点是什么？\"><a href=\"#区别于深度学习，强化学习的本质特点是什么？\" class=\"headerlink\" title=\"区别于深度学习，强化学习的本质特点是什么？\"></a>区别于深度学习，强化学习的本质特点是什么？</h2><p><strong>两个定义</strong></p>\n<p>1，强化学习是机器学习的一个重要分支，主要用来解决连续决策问题。</p>\n<p>2，强化学习又称 再励学习，评价学习或增强学习，是机器学习的范式和方法论之一，用于描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。</p>\n<p>强化学习的本质是<font color=\"red\"> 描述和解决智能体（agent）在于环境交互过程中通过学习策略以达成回报最大或实现特定目标的问题。</font>它本质是这样一种场景，在这种场景中它为了达到某种目的，做出连续的决策。这样符合这种场景，那就是强化学习。</p>\n<p>强化学习和深度学习这两个名词的维度是不一样的。深度学习描述的是算法本身的特点，深度够不够，是不是连接主义的模型。深度学习可以用来做无监督，也可以用来做半监督，也可以用来做弱监督，甚至可以用来作为强化学习算法的一部分。深度学习这个名词，不管应用场景只管模型本身是不是满足深度学习的特点。</p>\n<p>而强化学习描述的是应用场景的特点，只要能提供智能体决策的算法，管它是什么模型，什么结构，那就是强化学习的算法。从这个角度上讲，我现在认为强化学习和监督学习，无监督学习，弱监督学习，是并列的，是对应用场景的描述。和深度学习不是同一维度的。</p>\n<p><font color=\"red\">强化学习的本质在于目标给定的形式，不像无监督学习那样完全没有学习目标，也不像监督学习那样有非常明确的目标（label），强化学习的目标一般是变化的，不明确的，甚至可能不存在绝对正确的目标。，强化学习的问题都可以抽象成，环境状态，行动和奖励。应该说只要能抽象为这三个要素，目标是获得最大奖励的模型，就是强化学习的模型。</font></p>\n<p>强化学习的最大的特点是“试错”，是尝试各种可能，而强化结果好的可能。（策略网络的特点，估值网络的特点是修正和预测获益）</p>\n<p>由于强化学习是一种决策学习，这个问题的特点就是离散型。但是离散并不就是强化学习（连续的决策才是，目标的模糊和不确定性是决策问题的特点）。深度学习本质是函数的拟合，所以连续可微是它的特点。并不能说连续可微的问题就是深度学习，离散的问题就是强化学习。 </p>\n<h2 id=\"深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\"><a href=\"#深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\" class=\"headerlink\" title=\"深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？\"></a>深度学习用梯度下降的算法实现模型的优化，强化学习无法求导，甚至连学习目标都是模糊的如何优化模型参数？</h2><p>这个问题要了解下一节，具体的强化学习方法。</p>\n<h2 id=\"强化学习与弱监督学习？\"><a href=\"#强化学习与弱监督学习？\" class=\"headerlink\" title=\"强化学习与弱监督学习？\"></a>强化学习与弱监督学习？</h2><p>弱监督是属于有监督学习，只是它学习的目标不是被给予的标签，而是比被给予标签更强的标签（强弱是指标签做含有的信息量），也就是说弱监督是根据少量信息的标签，推测出更多的信息。</p>\n<p>强化学习的本质是连续决策。连续决策的特点是目标的模糊和不确定性。</p>\n<p>所以，虽然弱监督和强化学习都没有给出最终准确的目标，但是他们任然很不同的</p>\n<h2 id=\"深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\"><a href=\"#深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\" class=\"headerlink\" title=\"深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法\"></a>深度学习是死的，没有智能的机器学习算法，强化学习是“活的”，有智能的机器学习算法</h2><p>深度学习大部分我们用作有监督的学习算法。其实说深度学习是死的，不如说有监督学习是死的。</p>\n<p>有监督学习其实是完全的复刻标签里面含有的知识，它的本质就是一个函数拟合的问题，它无法摆脱对绝对的标签的依赖，无法超越标签。</p>\n<p>而强化学习，正由于它的目标是模糊和不确定的。使得算法在设计上必须具有随机性和探索性，它能够探索出人类从来没有到过的领域。就像在围棋上，下出人类完全无法理解的棋，人从来没有想过的一些下法。这就是强化学习算法探索出来的知识。所以我觉得它是活着的，拥有智能的算法。</p>\n<p><font color=\"green\">从感性的层面，强化学习算法很接近人脑的行为：感知环境，探索环境，强化有益行为</font></p>\n<h2 id=\"关于深度学习，强化学习，连续可导性和离散不可导性的讨论\"><a href=\"#关于深度学习，强化学习，连续可导性和离散不可导性的讨论\" class=\"headerlink\" title=\"关于深度学习，强化学习，连续可导性和离散不可导性的讨论\"></a>关于深度学习，强化学习，连续可导性和离散不可导性的讨论</h2><ol>\n<li><p>从函数的角度，深度学习和强化学习都需要学习一个函数映射。深度学习是从输入到target的映射。强化学习是学从环境状态到Action的映射。这两个映射可以看成性质一样的，因为深度学习可以作为强化学习的智能体。所以从函数的角度，他们没有连续和离散的区别。（PS. 深度学习模型和强化学习的智能体都是连续可导的函数。target和Action都可以是离散的或者连续的。）</p>\n</li>\n<li><p>深度学习作为用梯度下降算法优化的模型，无法优化对loss不可导的参数。如在深度学习中，设计一个分支来决定模型是否应该包含某个模块，这个分支的参数是不可优化的。因为包含和不包含是离散的，对loss不可导。</p>\n<p>不过假设，如果包含与不包含是连续的。也就是说，可以以0.1的权重包含。那么，这些参数是可以优化的。从这点来看，离散就是导致模型参数不可优化的原因。</p>\n</li>\n<li><p>强化学习在离散的情况下解决2中的问题。由此，我得到了一个概念，强化学习解决离散的问题。</p>\n</li>\n<li><p>下面我们来分析一下这个场景。首先，决定一个模块该不该被使用，这个场景是一次Action的场景，不是连续决策的场景。也就是说Action一次，我就能知道最终reward多少了，只有单步的reward。</p>\n<p>限于这个单次决策的场景来看，如果Action相对于reward是连续可导的，那么深度学习就能解决这个问题。如果Action相对于reward是离散的，那么仅仅深度学习无法解决这个问题，要靠强化学习。</p>\n<p><font color=\"green\">这里单次Action就知道reward，实际上这个问题就退化为了有监督学习，因为这个单步的reward就可以看成我的标签了。所以深度学习解决这个问题是很自然的。</font></p>\n</li>\n<li><p>多次决策的问题，无论是连续的还是离散的都只能用强化学习的方法。因为多次决策，这个问题就不可以退化为监督学习的问题了。它是一个真正的强化学习的问题。</p>\n</li>\n</ol>\n<p>综上所诉，强化学习解决深度学习解决不了的离散问题，那只是在单次决策的时候，这个问题退化为了有监督学习。强化学习的方法，恰好可以提供离散变量的学习。</p>\n<p>强化学习方法解决深度学习中的离散问题，仅仅是强化学习附带的一个小福利。</p>\n<p><strong><font color=\"green\">因为它能把经验转化为可导的目标，就拿策略网络来说，从梯度的角度，它只管增加当前随机Action的概率，而加入advatage之后，自动就优化除了想要的大reward的行为。</font></strong></p>\n<h2 id=\"深度学习优化和强化学习优化的感性理解\"><a href=\"#深度学习优化和强化学习优化的感性理解\" class=\"headerlink\" title=\"深度学习优化和强化学习优化的感性理解\"></a>深度学习优化和强化学习优化的感性理解</h2><p>前面说了深度学习优化可导的参数，强化学习可以优化不可导的参数。这里说一下对深度学习优化方法和强化学习优化方法的感性理解。</p>\n<p>还是说前面包不会包含某模块的例子，由于连续可导，对于每一个参数值，深度学习模型其实都同时参与了两种Action（包含和不包含）。score = 0.1 包含，其实其中包含了含有的成分，也包含了不含有的成分。所以我们可以连续的变动score，看看包含多好，还是不好含多好。这其实就是梯度下降算法的方式。得益于每一个参数，其实我都对包含和不包含的情况都有了解，我当然知道哪个更好，就往那边移动（优化）。</p>\n<p>然而，对于离散的情况，要么只能包含，要么只能不包含。当选择包含的时候，模型对不包含的情况完全是无知的。可能更好，也可能差。当不包含的时候，也是一样的。无论哪种情况，我都没有办法优化，两种情况是完全隔离开的，信息不沟通的，是离散的。所以梯度下降算法无法优化它。</p>\n<p>强化学习用随机探索的方法让两者信息又沟通起来。包含一下试一下，然后，不包含也试一下。尝试的结果是哪种reward多，就增大哪种的概率。</p>\n<p><strong><font color=\"green\">所以，无论哪种优化方法，信息的沟通都是必要的。要对所有的action都了解，才能知道选择哪种action。 只是深度学习是连续的，它的每一种参数，都包含了所有Action的信息（reward），每一种Action都参与了，所以它能直接连续的梯度下降的优化，不需要随机探索了。而对于离散的，每种action只能知道自己的reward，对其他Action一无所知的时候，梯度的优化是不行的。必须要探索各种Action，还是要知道了每一种Action的情况(reward)之后，才能优化。这是方法论。</font></strong></p>\n<p>更进一步，离散的地方，相对于reward一定是不可导的，所以深度学习不行。而强化学习，更准确的说是策略网络，相当于给离散的地方加了标签，这样它就在离散的地方有监督了，它就可以根据增加的标签优化。而标签的设计就是根据探索的结果，增大reward大的Action，reward大的Action就是它的标签，而且这个标签是动态的，是对抗得出的。</p>\n<p>强化学习方法算出的梯度是策略梯度。</p>\n<p><strong><font color=\"green\">强化学习： 不知道选哪边了； 试试呗；按试出来reward大的Action优化它。</font></strong></p>\n<p><strong><font color=\"green\">强化学习：它离散，对于reward不可导；不直接用reward优化它，给它加个标签，把试出来reward大的Action，作为标签去优化</font></strong></p>\n<p>在不可导的地方加标签。</p>\n<p><strong><font color=\"green\">由此，强化学习算法的本质是制作标签，无论是连续决策，标签不确定的情况，还是它能解决离散问题的情况，它都是用制作标签的方法解决的。</font></strong></p>\n<h1 id=\"策略网络-Policy-Network-和估值网络-Value-Network\"><a href=\"#策略网络-Policy-Network-和估值网络-Value-Network\" class=\"headerlink\" title=\"策略网络(Policy Network)和估值网络(Value Network)\"></a>策略网络(Policy Network)和估值网络(Value Network)</h1><p>AlphaGo 使用了快速走子，策略网络，估值网络和蒙特卡洛搜索树等技术。</p>\n<p>强化学习算法的一个关键是<font color=\"green\">随机性和探索性</font>，我们需要让算法通过试验样本自己学习什么才是某个环境状态下比较好的Action，而不是像有监督学习一样，告诉模型什么是好的Action，因为我们也不知道什么是好的Action.</p>\n<p>深度强化学习模型的本质是神经网络，神经网络是工具，根据问题转化以及建模的不同，主要分为策略网络和估值网络。</p>\n<p>强化学习中最重要的两类方法<strong>Policy-based,Value-based</strong>。第一种直接预测在某个环境下应该采取的行动（直接输出改采取Action的概率）。第二种预测在某个环境下所有行动的期望价值，然后通过选择q值最高的行动执行策略。</p>\n<p>他们都能完成决策，但由于建模的不同，估值网络包含有更多的信息，它不仅能提供决策，还预测了决策带来的收益。</p>\n<p><font color=\"red\">策略网络是隐式的学习了某一Action所带来的全部获益（当前获益+后续获益），而估值网络直接显示的学习Action所带来的全部获益。</font>强化学习算法做出最佳抉择只需要知道哪个Action全部获益最大，策略网络就是这样做的，估值网络不仅学习了哪个Action全部获益最大，还把每个Action的全部获益给计算出来了。</p>\n<p><font color=\"green\">相对来说，策略网络的性能会比估值网络好一些。</font></p>\n<p><font color=\"green\">Value Based方法适合仅有少量Action的环境，而Policy Based方法更通用，适合Action种类非常多，或者具有连续取值的Action的环境。结合了深度学习之后，Policy Based方法就变成了策略网络，Value Based方法就变成了估值网络。</font></p>\n<h2 id=\"策略网络-Policy-Network\"><a href=\"#策略网络-Policy-Network\" class=\"headerlink\" title=\"策略网络(Policy Network)\"></a>策略网络(Policy Network)</h2><p>直接看一个例子，学习的目标是，左右用力使得木棍不倒地，<a href=\"https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py\">Policy_Network.py</a></p>\n<p>关键代码</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = tf.matmul(layer1,W2)</span><br><span class=\"line\">probability = tf.nn.sigmoid(score)<span class=\"comment\">#网络输出采取Action 1的概率。</span></span><br><span class=\"line\">input_y = tf.placeholder(tf.float32,[<span class=\"literal\">None</span>,<span class=\"number\">1</span>], \\\\</span><br><span class=\"line\">                         name=<span class=\"string\">&quot;input_y&quot;</span>)<span class=\"comment\"># 输入采取过的行为，这个行为是随机生成的。</span></span><br><span class=\"line\">advantages = tf.placeholder(tf.float32,name=<span class=\"string\">&quot;reward_signal&quot;</span>) </span><br><span class=\"line\"><span class=\"comment\"># 输入获益</span></span><br><span class=\"line\">loglik = tf.log(input_y*(input_y - probability) + \\\\</span><br><span class=\"line\">                (<span class=\"number\">1</span> - input_y)*(input_y + probability)) </span><br><span class=\"line\"><span class=\"comment\"># 损失函数，如果行为是1，则增大</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#概率，如果行为是 0，则减小概率（相当于也是增加0的概率），也就是说这个损</span></span><br><span class=\"line\"><span class=\"comment\">#失函数无论当前行为是什么都会增大当前行为的概率。</span></span><br><span class=\"line\">loss = -tf.reduce_mean(loglik * advantages) <span class=\"comment\"># 这行代码很关键，</span></span><br><span class=\"line\"><span class=\"comment\">#相当于给损失函数成了一个权重advantages，得到最终的损失函数。</span></span><br><span class=\"line\"><span class=\"comment\">#advantages是当前试验的全部获益。如果全部获益大，将以更大的权重，增加 </span></span><br><span class=\"line\"><span class=\"comment\">#当前行为的概率。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#所以，策略网络其实也是一个对抗学习的过程，增加所有采取过行为的概率，只是</span></span><br><span class=\"line\"><span class=\"comment\">#获益多的行为以更大的权重增加。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 一个试验： 由初始状态开始，随机采取一连串的行为</span></span><br><span class=\"line\"><span class=\"comment\">#（Policy_Network.py 中是根据当前模型输出的概率,来生成随机的行为，但</span></span><br><span class=\"line\"><span class=\"comment\">#是我感觉直接用0.5的概率随机生成一连串的0和1的行为也是可以的，下面将实</span></span><br><span class=\"line\"><span class=\"comment\">#验一下），直到任务结束。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 由于每个试验，都可以一直行为到任务结束，所以每个action，我们都可以得</span></span><br><span class=\"line\"><span class=\"comment\">#到它在该试验中的全部获益（当前获益 + 之后所有行为的获益）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 随机生成了n个试验，其中又各种各样的决策（随机探索），全部获益大的</span></span><br><span class=\"line\"><span class=\"comment\">#action，它的advantages也大，那么它的概率就增大的多，它被强化的厉害。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 试验生成的过程，实际上就是数据集构建的过程。策略网络的数据集是由环境</span></span><br><span class=\"line\"><span class=\"comment\">#和一系列随机的行为构成的。它提供了环境在各种行为下的反应（获益）。模型</span></span><br><span class=\"line\"><span class=\"comment\">#学习为环境带来高获益的行为的规律。</span></span><br></pre></td></tr></table></figure>\n\n<p>由上面的代码可知，从策略网络的角度看强化学习的话，强化学习的关键其实是对数据集的构建—如何构建数据集。</p>\n<p>在构建数据集的时候，随机探索肯定是必要的。随机探索的结果会得到一系列好的行为，也会得到一系列不好的行为。如何强化好的行为就是算法设计的时候需要注意的。</p>\n<p>上面的代码在探索阶段借用了当前的模型，即根据当前模型输出的概率随机生成行为，从而形成数据集。如果完全的随机（一直使用0.5的概率随机的生成Action）会什么样呢？</p>\n<h3 id=\"数据集是否可以和模型无关（不随着模型变化）？\"><a href=\"#数据集是否可以和模型无关（不随着模型变化）？\" class=\"headerlink\" title=\"数据集是否可以和模型无关（不随着模型变化）？\"></a>数据集是否可以和模型无关（不随着模型变化）？</h3><p>关键修改代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#基于当前模型，根据当前的状态x，生成Action 1的概率</span></span><br><span class=\"line\">tfprob = sess.run(probability,feed_dict=&#123;observations: x&#125;)</span><br><span class=\"line\"><span class=\"comment\"># 基于预测概率，随机生成行为，并试探环境。生成数据集。</span></span><br><span class=\"line\">action = <span class=\"number\">1</span> <span class=\"keyword\">if</span> np.random.uniform() &lt; tfprob <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>修改后</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 注释掉这句，并不需要根据当前模型生成概率</span></span><br><span class=\"line\"><span class=\"comment\"># tfprob = sess.run(probability,feed_dict=&#123;observations: x&#125;)</span></span><br><span class=\"line\"><span class=\"comment\"># 直接设置概率为0.5，随机完全随机探索生成数据集。</span></span><br><span class=\"line\">tfprob = <span class=\"number\">0.5</span></span><br><span class=\"line\">action = <span class=\"number\">1</span> <span class=\"keyword\">if</span> np.random.uniform() &lt; tfprob <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>结果：修改后，模型无法收敛。</p>\n<p>完全随机很小的概率能探索出很好的试验，这些好的行为也很难持续的得到强化。</p>\n<p>所以，强化学习也有一种效果叠加的感觉。在完全随机的情况下 ，探索出相对好的action，再在这个相对好的action的基础上，在探索探索出更好的action。</p>\n<p>如果数据集不依赖模型，就是一直在完全随机的基础上探索。这样很难收敛。</p>\n<p>也可以这样看，完全随机的话，最多能学到前几步的策略（因为完全随机就走不了几步，探索的经验就只有那几步）。依赖于模型，探索的行为更有价值，因为是依赖于学到过的知识的，一方面确认了，按学到的知识走，确实获益多，一方面又在学到的知识的基础上，做了一些随机，探索更好的知识。</p>\n<h2 id=\"估值网络-Value-Network，Q-learning\"><a href=\"#估值网络-Value-Network，Q-learning\" class=\"headerlink\" title=\"估值网络(Value Network，Q-learning)\"></a>估值网络(Value Network，Q-learning)</h2><p>Q-Learing用神经网络实现，得到的模型就是估值网络。</p>\n<p>也看一个例子，<a href=\"https://github.com/xyegithub/myBlog/blob/main/2021/12/03/First-Step-to-RL/policy_network.py\">Value_Network.py</a></p>\n<p>学习每个Action所对应的reward的期望。</p>\n<p>我们先看看数据集的结构</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Save the experience to our episode buffer.</span></span><br><span class=\"line\">episodeBuffer.add(np.reshape(np.array([s,a,r,s1,d]),[<span class=\"number\">1</span>,<span class=\"number\">5</span>]))</span><br><span class=\"line\"><span class=\"comment\"># 其中s是当前时刻的环境状态，a是当前随机采取的Action，r是这个Action的当前reward</span></span><br><span class=\"line\"><span class=\"comment\"># s1是采取Action之后的下一状态，d是布尔型表示是否任务结束。  </span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>现在目标是学习Q(s<sub>t</sub>, a<sub>t</sub>)，也就是当前环境状态，采取行为a的全部reward的期望。</p>\n</li>\n<li><p>现在假设我们有模型Q<sub>desird</sub>，可以预测全部reward了，那么这个模型应该满足条件，Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，这有点递归的感觉了。</p>\n</li>\n<li><p>现在我们能不能根据这个公式 ， 来优化出Q<sub>desired</sub>。肯定是能的。对于探索过的所有试验，公式都满足的话，此时的模型就可以看成我们想要的模型了。我感觉这就是估值网络方法的核心。</p>\n</li>\n</ol>\n<p>直接看关键代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Choose an action by greedily (with e chance of random action)</span></span><br><span class=\"line\"><span class=\"comment\"># from the Q-network</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> np.random.rand(<span class=\"number\">1</span>) &lt; e <span class=\"keyword\">or</span> total_steps &lt; pre_train_steps:</span><br><span class=\"line\">    a = np.random.randint(<span class=\"number\">0</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    a = sess.run(mainQN.predict,feed_dict=&#123;mainQN.scalarInput:[s]&#125;)[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># 这段代码其实是探索的代码，当最开始的时候是完全随机探索（total_steps &lt; pre_train_steps的时候）</span></span><br><span class=\"line\"><span class=\"comment\"># 当total_steps &gt;= pre_train_steps之后呢，就不是完全随机探索了。</span></span><br><span class=\"line\"><span class=\"comment\"># 有e的概率是随机探索的，（1-e）的概率是由训练好的模型决定之后的Action。 </span></span><br><span class=\"line\"><span class=\"comment\"># 这里是估值网络和策略网络的不同，策略网络本身就具有随机性，所以不需要引入</span></span><br><span class=\"line\"><span class=\"comment\"># 额外的参数e和pre_train_steps来控制随机探索的强度。</span></span><br><span class=\"line\"><span class=\"comment\"># 策略网络在训练的过程中，本身就是由随机性大，到慢慢的收敛到好的Action</span></span><br><span class=\"line\"><span class=\"comment\"># 所以可以直接得到好的探索的训练样本。估值网络没有这样好的性质，它连</span></span><br><span class=\"line\"><span class=\"comment\"># 随机性都没有，就需要人为的制造，满足从完全随机探索，到在好的Action的</span></span><br><span class=\"line\"><span class=\"comment\"># 基础上具有一定的随机性进行探索。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>这是策略网络和估值网络的共通之处，其实这也最上面那个注释”by greedily (with e chance of random action) from the Q-network”的意思。</strong></p>\n<p><strong><font color=\"green\">“贪心”两个字完美的诠释了强化学习，无论是策略网络还是估值网络，在探索阶段，在生成数据集上的特点。</font></strong></p>\n<p>在策略网络那一节，我做的那个试验，和模型无关生成数据集。其实就是不贪心了，不贪心不行。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> total_steps &gt; pre_train_steps:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> e &gt; endE:</span><br><span class=\"line\">        e -= stepDrop</span><br><span class=\"line\"><span class=\"comment\"># 完全随机了之后，开始慢慢减小随机性。</span></span><br><span class=\"line\"><span class=\"comment\"># 模型约不可靠的时候，探索性和随机性越强。后来模型慢慢变得可靠就减弱随机性。</span></span><br><span class=\"line\"><span class=\"comment\"># 因为模型越来越可靠的时候，随机性大就会得到很多远远低于当前模型性能的试验</span></span><br><span class=\"line\"><span class=\"comment\"># 这些试验都是早就被pass了的，学不到什么东西，损坏模型的探索。</span></span><br><span class=\"line\"><span class=\"comment\"># endE=0.1 说明无论训练的多好，模型都保持了随机性，保持了探索性</span></span><br><span class=\"line\"><span class=\"comment\">#　人永远要有好奇心，永远要觉得自己的知识还可能不是最好的</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>下面的代码是将在数据集弄好的情况下，如何训练模型的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> total_steps % (update_freq) == <span class=\"number\">0</span>:</span><br><span class=\"line\">    trainBatch = myBuffer.sample(batch_size) <span class=\"comment\">#Get a random batch of experiences.</span></span><br><span class=\"line\">    <span class=\"comment\">#Below we perform the Double-DQN update to the target Q-values</span></span><br><span class=\"line\">    <span class=\"comment\"># 主网络预测了下一刻需要采取的Action，trainBatch[:,3]是当前的下一刻的环境</span></span><br><span class=\"line\">    <span class=\"comment\"># 回顾公式，Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)</span></span><br><span class=\"line\">    <span class=\"comment\"># 这里主函数预测的Action就是t+1时刻（下一时刻）获益值最大的Action</span></span><br><span class=\"line\">    Q1 = sess.run(mainQN.predict,feed_dict=&#123;mainQN.scalarInput:np.vstack(trainBatch[:,<span class=\"number\">3</span>])&#125;)</span><br><span class=\"line\">    <span class=\"comment\"># target网络预测了下一时刻的reward</span></span><br><span class=\"line\">    Q2 = sess.run(targetQN.Qout,feed_dict=&#123;targetQN.scalarInput:np.vstack(trainBatch[:,<span class=\"number\">3</span>])&#125;)</span><br><span class=\"line\">    end_multiplier = -(trainBatch[:,<span class=\"number\">4</span>] - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 用主网络预测出的Action以及target网络预测出的所有行为的reward</span></span><br><span class=\"line\">    <span class=\"comment\"># 选择了最大的reward,也就是公式中的 Max Q(s_t+1, a)</span></span><br><span class=\"line\">    doubleQ = Q2[<span class=\"built_in\">range</span>(batch_size),Q1]</span><br><span class=\"line\">    <span class=\"comment\"># 这里得到的就是公式Q(st, at) = r + $\\lambda$ Max Q(s_t+1, a)</span></span><br><span class=\"line\">    <span class=\"comment\"># 的右边，当前reward加上乘以衰减系数之后的，下一步最大reward</span></span><br><span class=\"line\">    targetQ = trainBatch[:,<span class=\"number\">2</span>] + (y*doubleQ * end_multiplier)</span><br><span class=\"line\">    <span class=\"comment\">#Update the network with our target values.</span></span><br><span class=\"line\">    <span class=\"comment\"># 公式右边得到了之后，在把真正的当前状态输入进去，得到左边</span></span><br><span class=\"line\">    <span class=\"comment\"># 左边以右边作为标签进行学习。更新主网络的参数</span></span><br><span class=\"line\">    _ = sess.run(mainQN.updateModel, \\</span><br><span class=\"line\">                 feed_dict=&#123;mainQN.scalarInput:np.vstack(trainBatch[:,<span class=\"number\">0</span>]),mainQN.targetQ:targetQ, mainQN.actions:trainBatch[:,<span class=\"number\">1</span>]&#125;)</span><br><span class=\"line\">    <span class=\"comment\"># 更新target网络的参数。</span></span><br><span class=\"line\">    updateTarget(targetOps,sess) <span class=\"comment\">#Update the target network toward the primary network.</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>target网络参数的更新方式代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">updateTargetGraph</span>(<span class=\"params\">tfVars,tau</span>):</span></span><br><span class=\"line\">    total_vars = <span class=\"built_in\">len</span>(tfVars)</span><br><span class=\"line\">    op_holder = [] </span><br><span class=\"line\">    <span class=\"comment\"># 主网络是和target网络一样的，前一半参数正好是主网络的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx,var <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(tfVars[<span class=\"number\">0</span>:total_vars//<span class=\"number\">2</span>]):</span><br><span class=\"line\">        <span class=\"comment\"># idx+total_vars对应的时候后一半的参数也就是target网络的参数</span></span><br><span class=\"line\">        <span class=\"comment\"># 这里相当于是target参数 = 主网络参数 * tau + （1- tau）*target参数</span></span><br><span class=\"line\">        <span class=\"comment\"># 也就是说target网络在以一定的速度向主网络靠近</span></span><br><span class=\"line\">        <span class=\"comment\"># 结合前面的代码，主网络才是真正学习的网络，target网络的作用仅仅是得到等式</span></span><br><span class=\"line\">        <span class=\"comment\"># 右边的值，即标签，即使是等式右边，也不是target网络完全决定的</span></span><br><span class=\"line\">        <span class=\"comment\"># target网络得到了所有Action的reward，最大的Action是主网络选择的</span></span><br><span class=\"line\">        <span class=\"comment\"># 为什么要这么做，target网络也是在模仿主网络，只用主网络也能得到等式的右边</span></span><br><span class=\"line\">        <span class=\"comment\"># 理论上其实右边也应该是主网络决定，现在搞了个主网络的模仿者target网络</span></span><br><span class=\"line\">        <span class=\"comment\"># 是出于优化的考虑。我们后面叙述。</span></span><br><span class=\"line\">        op_holder.append(tfVars[idx+total_vars//<span class=\"number\">2</span>].assign\\\\</span><br><span class=\"line\">                         ((var.value()*tau) \\\\</span><br><span class=\"line\">                      + ((<span class=\"number\">1</span>-tau)*tfVars[idx+total_vars//<span class=\"number\">2</span>].value())))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> op_holder</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">updateTarget</span>(<span class=\"params\">op_holder,sess</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> op <span class=\"keyword\">in</span> op_holder:</span><br><span class=\"line\">            sess.run(op)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在其实我们把关键的代码都看了，在这段代码实现中，引入了一些state of the art的trick，下面我们结合看过的代码在提一遍。</p>\n<ol>\n<li>引入卷积层，这段代码比较简单，我们没有看。环境状态是用图片的形式给的，用CNN提取特征是比较自然的。</li>\n<li>Experience replay。估值网络不像策略网络一样得到试验之后，用一次就扔掉再去制作新的试验（数据集）来训练。它把每次试验都放在一个试验池里面。试验池长度为N，如果超过了N，那就把最老的试验样本扔掉。每次 训练的时候从试验池里面随机选择batchsize个样本进行训练，保持了对样本的利用率，同时其实也增加了模型的稳定性，因为数据集是相对稳定的（相比于N=1而言，每次训练了就扔掉，进来的都是新的，不那么稳定）。</li>\n<li>使用target网络来辅助训练。<strong>之所以要用target网络来制造训练目标，用主网络来实际训练，是为了让Q-Learing训练的目标保持平稳。</strong>强化学习不像普通的监督学习，它的目标是变化的，<strong>因为学习目标的一部分就是模型本身输出的。</strong>每次更新模型参数都会导致学习目标发生变化，如果更新频繁，幅度很大，我们的训练过程就会变得非常不稳定并且失控。<strong>DQN的训练会陷入目标Q与预测Q的反馈循环中，震荡发散。</strong>所以用target网络来制造目标，target网络和主网络又不是矛盾的，因为target网络会逼近主网络，它是主网络的模仿者，所以它提供的目标Q也是有权威的。</li>\n<li>Double DQN。这个trick源于target网络选的最大Action不准。模仿的不够好，现在就让主网络来帮它选。也就是上面代码中我们看过了主网络输出action，选择target网络输出的reward，得到公式的右边。</li>\n<li>Dueling DQN。上代码</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.AW = tf.Variable(xavier_init([h_size//<span class=\"number\">2</span>,env.actions]))</span><br><span class=\"line\">self.VW = tf.Variable(xavier_init([h_size//<span class=\"number\">2</span>,<span class=\"number\">1</span>]))</span><br><span class=\"line\">self.Advantage = tf.matmul(self.streamA,self.AW)</span><br><span class=\"line\">self.Value = tf.matmul(self.streamV,self.VW)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Then combine them together to get our final Q-values.</span></span><br><span class=\"line\"><span class=\"comment\"># 看这里Qout是网络最终预测的所有Action的reward。它由两部分组成Value和Advantage</span></span><br><span class=\"line\"><span class=\"comment\"># 由最上面两行可以看出Value是一维的，是实数，advantage是#action维度的向量</span></span><br><span class=\"line\"><span class=\"comment\"># 所以，Dueling DQN就是将reward裁成了两部分，一部分是环境状态本身具有的价值Value</span></span><br><span class=\"line\"><span class=\"comment\"># 另一部分就是Action本身具有的价值，相加起来就是在这个环境下Action具有的价值。</span></span><br><span class=\"line\"><span class=\"comment\"># 其实我感觉这些解释都是人为的，具体是不是这样谁也不知道，可能只是这样优化的好。</span></span><br><span class=\"line\"><span class=\"comment\">#　因为即使不分为两部分，网络输出Ｑout的时候，输入也是环境状态，肯定都会把环境考虑</span></span><br><span class=\"line\"><span class=\"comment\"># 进去才有Action的价值。然而直接输出这个价值，发现优化的不好，分为两部分之后，发现</span></span><br><span class=\"line\"><span class=\"comment\"># 优化的好了。其实谁也不知道其中到底是什么原因起作用。</span></span><br><span class=\"line\">self.Qout = self.Value + tf.subtract(self.Advantage,tf.reduce_mean(self.Advantage,axis=<span class=\"number\">1</span>,keep_dims=<span class=\"literal\">True</span>))</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"回顾\"><a href=\"#回顾\" class=\"headerlink\" title=\"回顾\"></a>回顾</h1><p>强化学习的本质是连续决策。强化学习算法的关键是标签制作，数据集制作。</p>\n<p>连续决策问题是没有确定的标签的，它通过探索试验得到数据集和标签，为没有提供标签的问题，做了标签，让问题可以解决。</p>\n<p>深度学习无法优化离散的不可导的参数，强化学习也可以通过在离散的地方做数据集做标签，把它转换为可导的，可用sgd优化的问题。</p>\n<p>做标签和数据集的关键是随机性以及贪心，贪心让它立足于以往的知识，随机让它不刚愎自用，保持谦卑，给新的可能保留空间。</p>\n<p>无论是策略网络还是估值网络，在数据集的制作上都是一样的，随机性和贪心。估值网络的数据集制作，可以看出强化学习探索的本质（由于估值网络本身没有随机性，它在制作数据集的时候，显示的暴露了，探索和贪心的本质。策略网络这方面还不太好看出来，因为它是隐式的利用探索和贪心）。</p>\n<p>策略网络，增大所有行为的概率，但是对于reward大 的行为增大的权重大。这个思路在我得感觉上更加符合强化两个字。强化好的行为嘛。</p>\n<p>估值网络的本质是公式Q<sub>desired</sub>(s<sub>t</sub>, a<sub>t</sub>) = r + $\\lambda$ Max<sub>a</sub> Q<sub>desired</sub>(s<sub>t+1</sub>, a)，有点递归的感觉。</p>\n<p>策略网络和估值网络数据集也有一点不同，策略网络的数据集是纵向的，一串行为一起的。而估值网络的数据集是单个单个的。</p>\n<p>由下面代码可以看出，策略网络中，每一窜试验就会训练一次，只是网络参数更新会积累了好几次试验之后才更新。策略网络关心从开始到结束一系列行为。而估值网络只关心当前和下一状态。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> done:</span><br><span class=\"line\">    episode_number += <span class=\"number\">1</span></span><br><span class=\"line\">    epx = np.vstack(xs)</span><br><span class=\"line\">    epy = np.vstack(ys)</span><br><span class=\"line\">    epr = np.vstack(drs)</span><br><span class=\"line\">    tfp = tfps</span><br><span class=\"line\">    xs,hs,dlogps,drs,ys,tfps = [],[],[],[],[],[]</span><br><span class=\"line\"></span><br><span class=\"line\">    discounted_epr = discount_rewards(epr)</span><br><span class=\"line\">    discounted_epr -= np.mean(discounted_epr)</span><br><span class=\"line\">    discounted_epr //= np.std(discounted_epr)</span><br><span class=\"line\"></span><br><span class=\"line\">    tGrad = sess.run(newGrads,feed_dict=&#123;observations: epx, input_y: epy, advantages: discounted_epr&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ix,grad <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(tGrad):</span><br><span class=\"line\">        gradBuffer[ix] += grad</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> episode_number % batch_size == <span class=\"number\">0</span>:</span><br><span class=\"line\">            sess.run(updateGrads,feed_dict=&#123;W1Grad: gradBuffer[<span class=\"number\">0</span>],W1_1Grad:gradBuffer[<span class=\"number\">1</span>],W2Grad:gradBuffer[<span class=\"number\">2</span>]&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>估值网络人为的控制随机强度，也是一个值得考虑的问题。</p>"}],"PostAsset":[{"_id":"source/_posts/First-Step-to-RL/policy_network.py","post":"ckx0fk1vp000gxoul8sy9efld","slug":"policy_network.py","modified":1,"renderable":1},{"_id":"source/_posts/First-Step-to-RL/q_learning.py","post":"ckx0fk1vp000gxoul8sy9efld","slug":"q_learning.py","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckx0fk1vb0001xoulcrslha8f","category_id":"ckx0fk1vi0004xoul35qkdqc0","_id":"ckx0fk1vo000cxoul70t33yfb"},{"post_id":"ckx0fk1vb0001xoulcrslha8f","category_id":"ckx0fk1vn0009xoul6nplajat","_id":"ckx0fk1vo000dxoul6zcqe072"},{"post_id":"ckx0fk1vf0003xoulhdpr8bxn","category_id":"ckx0fk1vi0004xoul35qkdqc0","_id":"ckx0fk1vp000exould6qh59k9"},{"post_id":"ckx0fk1vf0003xoulhdpr8bxn","category_id":"ckx0fk1vo000bxoul7gdt49wf","_id":"ckx0fk1vp000fxoul4yqmeote"},{"post_id":"ckx0fk1vp000gxoul8sy9efld","category_id":"ckx0fk1vq000hxoulb6zfgsag","_id":"ckx0fk1vr000kxoul1rx46jxv"}],"PostTag":[{"post_id":"ckx0fk1vb0001xoulcrslha8f","tag_id":"ckx0fk1vk0005xoul8yyh88gq","_id":"ckx0fk1vn0008xoulhsgd33pw"},{"post_id":"ckx0fk1vf0003xoulhdpr8bxn","tag_id":"ckx0fk1vm0007xoulhz8l3nuw","_id":"ckx0fk1vo000axoul6o87a3wm"},{"post_id":"ckx0fk1vp000gxoul8sy9efld","tag_id":"ckx0fk1vq000ixoul7e29asgu","_id":"ckx0fk1vr000jxoul7sxy09a9"}],"Tag":[{"name":"Hexo","_id":"ckx0fk1vk0005xoul8yyh88gq"},{"name":"Git","_id":"ckx0fk1vm0007xoulhz8l3nuw"},{"name":"Reinforcement Learning","_id":"ckx0fk1vq000ixoul7e29asgu"}]}}